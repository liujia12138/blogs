#### 从输入url到页面显示，发生了啥玩意
	1.在浏览器中输入url,检查是否有缓存
		如果有缓存，并且没有过期，就不发送请求，直接拿来解码在开始渲染流程
		检查的过程：
			1.如果是https的话，有可能先找service worker
			2.如果没有，在找浏览器的内存缓存(memory cache)
			3.如果还没有，在找硬盘缓存(disk cache)(强缓存和协议缓存都属于硬盘缓存)
			4.如果三种都没有找到的话，可能还会查找推送缓存(push cache)
			
	2.dns解析
		dns协议提供了通过域名查找ip地址，或者是你想ip反查域名的服务
		
		步骤
			1.首先查看本地dns如果找到对应域名就执行tcp的三次握手，如果没有找到就执行2
			2.去路由器的dns服务去找对因的ip，如果找到对应的域名就只行tcp三次握手，如果没有找到就执行3
			3.去代理服务器的dns服务去找对应的ip，如果找到对应的域名就执行tcp三次握手，如果没有找到就执行4
			4.代理服务器找不到，那么就去网络服务商哪里去找，找到采取执行tcp的三次握手
			
	3.tcp三次握手建立链接
		tcp协议：
			1.应用层（http协议属于该层）
				作用：向用户提供应用服务时通信的活动
			2.传输层（tcp协议属于该层）
				作用：提供两台计算机之间的数据传输
			3.网络层（ip协议属于该层）
				作用：用来处理网上流动的数据包。
			4.链路层
				作用：用来链接网络硬件的部分
				
		其中https就是在应用层和传输层之间添加了ssl
		
		三次握手：
			1.主机a发送位码为syn=1的tcp包给服务器，并随机产生了一个确认号，主机b收到syn码
			2.主机b收到请求后，向a发送确认好号，syn=1，seq=随机数的tcp包
			3.主机a收到后检查确认号是否正确，即第一次发送的确认号是否+1，以及位码是否为1，如正确，主机a再次发送确认号ack=1，主机b收到确认号后seq值与ack=1则链接建立成功
			
		为什么两次握手不行？
			因为第二次握手的时候主机b还不能确认主机a已经收到请求，如果这个时候开始发送数据，则攻击b就很容易了
			
			
	4.http发起请求
	5.服务器处理请求，并返回响应报文
	6.浏览器渲染dom树
		解析html生成dom树
		解析css生成cssom
		将dom和cssom合并成一个渲染树
		根据布局，来计算每个节点的集合信息
		将各个节点会知道屏幕上
		
	10.断开tcp链接，解释本次请求流程
		1.当服务器完成数据传输后，将控制位fim置1，提出停止tcp链接的请求
		2.客户端收到fim后对其作出相应，确认这一方向上的tcp链接将要关闭，将ack置为1
		3.有客户端再次提出反方向的关闭请求，将fin置1
		4.服务器对客户端的请求进行确认，将ack置1 ，双方的关闭结束
#### url为什么要解析呢
	因为网络标准规定了url只能是字母和数字，还有一些特殊字符，比较常见的就是不包括百分号和双引号
	
##### encodeURLComponent和encodeURL有什么区别
	encodeURIComponent的编码范围更加往返，适合给参数编码；
	encodeURI适合给url本身的编码
	
#### 页面优化
	1.html文档结构层次尽量少，最好不要深于6层
	2.脚本尽量往后方
	3.少量首屏样式内联放在标签内
	4.样式结构层次尽量简单
	5.在脚本中尽量减少dom操作。
	6.减少通过js代码修改元素的样式，尽量使用class名方式操作样式和动画
	7.动画尽量使用在绝对定位和固定定位的元素上
	
#### 如何让文件加载更快(缓存，网络)
	1.网络缓存分为：dns缓存、http缓存、cdn缓存
	2.本地：浏览器的本地存储和离线存储
	
	1.DNS缓存：
		第一次进入页面后就会把dns解析的地址记录缓存在客户端，之后在进行的话就不需要进行后面的迭代查询了，从而速度更快
		
	2.http缓存
		就是将http请求获取的页面资源存储在本地，之后再加载就直接从缓存中获取
		
		1.强缓存
			第一次请求时，服务器把资源的过期时间通过响应头中的Expires和Cache-control
			两个字段告诉浏览器，之后在请求这个资源的还，会判断有没有过期，没有过期就直接拿来用，不想服务器发送请求，这就是强缓存
			
			expries
				用来制定资源的到期绝对时间，服务器响应时，添加在响应头中
					
			Cache-control
				指定资源过期时间
				
			2.为什么指定缓存过期时间需要两个字段呢？
				因为有的浏览器只认识cache-control，有的浏览器不认识，在不认得情况下在找expires
				
			3.两者的区别
				expires时http1.0中的，cache-control是http1.1中的
				expires是为了兼容的，在不支持cache-control的情况下使用
				如果两者都存在那么cahche-control的优先级高于expires
				
			4.cahce-control的常见属性
				max-age=300 超过300秒过期
				max-stale=100 缓存过期100之内还可以使用
				min-fresh=50缓存到期时间还剩50秒的时候不可用
				no-cache 协商缓存验证
				no-store 不缓存
				only-if-chached 只是用缓存
				
			5.缺点
				缓存过期知乎，不管资源是否发生变换，都会重新发起请求，获取资源
				
		2.协商缓存
			第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加last-modified字段，告诉浏览器该资源的最后修改时间
			然后浏览器再次请求的时候就会把这个时间再通过另一个字段if-modified-since，发送给服务器
			服务器在把这两个字段的时间对比，如果一样说明文件没有被更新，则返回304，浏览器直接拿过期的资源继续使用即可；如果对比不一样说明资源有被更新，则返回状态码200和新的资源
			
			1.缺点
				1.如果本地打开缓存文件，即使没有对文件进行修改，但是还是会对last-modified造成影响，导致服务器不能够命中缓存导致发送相同的资源
				2.因为last-modified只能以秒计算，如果在不可感知的时间内修改了文件，服务器端认为还是命中，无法返回正确的资源
				3.如果资源有周期性变化，如资源修改后，在一周期内又改回了原来的样子，我们认为这个周前的缓存是可以使用的，但是last-modified不这样认为
				
				
		ETag/If-None-Match
			第一次请求资源时，服务器除了会在响应头上返回expires，cache-control，last-modified，还返回了ETag，表示当前资源的唯一标识。这个表示由服务器基于文件内容编码生成的，只要文件内容不同，etag就会重新生成。
			然后浏览器再次请求的时候就把这个文件标识再通过另一个字段if-none-match，发送给服务器
			服务器再把这两个字段的时间对比，如果发现是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用；如果对比不一样说明资源有更新，就返回状态码200和新的资源
			
			last-modified与etag的区别
				1.etag感知文件精准度要高于last-modified
				2.同时使用的话，服务器校验优先级etag/if-none-match
				3.last-modified性能要优于etag，因为etag生成过程中需要服务器付出额外的开销，会影响服务器端的性能，所以它并不能完全代替last-modified，只能作为补充和强化
				
	
		强缓存和协商缓存的区别
			1.优先查找强缓存，没有找到在查找协商缓存
			2.强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，资源是否有更新，服务器肯定知道
			3.目前项目大多数使用缓存的方案
				1.协商缓存：html
				2.强缓存：css image js 文件名带上hash
			
			
	3.启发式缓存
			就是响应中没有expires，cache-control，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算缓存有效期
			max(0,(Date - last-modified)) %10
			
			
#### 缓存实际使用策略
	对于频繁变动的资源
		使用cache-control：no-cache，是浏览器每次都请求数据，然后配合etag/if-none-match或last-modified/if-modified-since来验证资源是否有效，这样虽然不能节省请求数量，但是能够显著较少响应数据的大小
		
	对于不长变化的资源
		可以给他们的cache-control配置一个很大的max-age = 31536000,这样浏览器之后请求相同的url会命中强缓存，从而解决问题，就需哟在文件名中添加hash，版本号等动态字符，之后更改动态字符，从而达到引用url的目的，让之前的强缓存失效
		
#### 缓存存放位置和读取的优先级
	1.service worker
		离线存储
			是运行js主线程之外的，在浏览器背后的独立咸亨，自然无法访问dom，它相当于一个嗲里服务器，可以拦截用户发出的请求，修改请求或者直接向用户发出响应，不用联系服务器
			
			一般用于离线缓存（提高首屏加载速度），消息推送，网络代理等使用service worker必须使用https协议，因为service worker涉及到请求拦截，需要https保证安全
			
			用service worker来实现缓存的三步
				1.注册
				2.监听install事件后就可以缓存文件
				3.下次在访问的时候就可以通过拦截请求的方式直接返回缓存的数据
				
				
		<!-- index.js注册 -->
		if(navigator.serviceWorker){
			navigator.serviceWorker.install('sw.js')
				.then(res => {
					console.log('注册成功');
				})
				.catch(err => {
					console.log('注册失败');
				})
		}
		
		<!-- sw.js监听install事件，回调中缓存所需文件 -->
		self.addEventListener('install',e => {
			<!-- 打开指定的缓存文件名称 -->
			e.waitUntil(caches.open('my-cache').then(cache => {
				<!-- 添加需要缓存的文件-->
				
				return cache.addAll(['./index.html','./index.css'])
			}))
		})
		
		<!-- 拦截所有请求事件 缓存中有请求数据就直接用缓存，否则就去请求数据-->
		self.addEventListener('fetch',e => {
			<!--查找request中被缓存命中的response -->
			e.respondWith(caches.match(e.request).then(response => {
				if(response){
					return response
				}
			}))
		})
	2.memory cache(内存)
		将资源存储在内存中，下次访问直接从内存中读取，
		优点：读取速度快，缺点是一旦关闭页面内存中的缓存也就释放了
		
	3.disk cache(硬盘)
		将资源存储在硬盘中，下次访问时直接从硬盘中读取。
		优点：容量大，并且存储时间长，缺点：读取的速度会慢一些
		
	4.push cache
		这个是推送缓存，是http2中的内容，上面三种缓存都没有命中的时候才会被使用，它只存在与session中，一旦回话被释放，所以缓存时间会很短并且只能使用一次
#### indexDB是浏览器本地数据	
####cnd缓存

##### webpack项目优化                                                                                                                                                                                                                               
https://juejin.cn/post/6844904045417594893

#### 虚拟列表
	1.按需显示的一种实现，支队可见区域进行渲染，对非可见区域中的数据不渲染或者是部分渲染的技术，从而达到极高的渲染性能
	
	实现：
		1.计算当前可视区域起始数据索引
		2.计算当前可视区域的结束索引
		3.计算当前可视区域的数据，并渲染到页面
		4.计算startIndex对应的数据在整个列表中偏移位置startOffset并设置到列表上
		
	假设：
		1.假设可视区域的高度固定，称之为screenHeight；
		2.假设列表每项高度固定，称之为itemSize;
		3.假设列表数据 称之为listData
		4.假设当前的滚动位置称之为scrollTop
		
		
		