### http 缓存

#### 1.强缓存
1.定义:强缓存是当我们访问 url 的时候，不会像服务器发送请求，直接从缓存中读取资源，但是会返回 200 的状态码

2.强缓存如何设置：
  我们第一次进入到页面中，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对浏览器资源进行缓存，如果响应头中的expires，pragma或者是cache-control字段，代表这是强缓存，浏览器会被资源缓存在memory cache或者是disk cache中。

  第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码304，不符合则服务器会返回全新的资源

3.属性：
  ·expires:是http1.0控制网页缓存的字段，值为一个时间戳，缺点是他判断是否过期是用本地时间来判断，本地时间是可以自己修改的。

  ·cahce-control：是http1.1中控制网页缓存的字段，当cahche-control都存在时，cache-control优先级更高，主要取值为：
    public：资源客户端和服务器都可以缓存
    privte：资源只有客户端可以缓存
    no-chache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证
    no-store:不使用缓存
    max-age:缓存保质期

5.缓存位置
存储图像和网页等资源主要缓存在disk cache，操作系统缓存文件等资源大部分都会缓存在memory cahce中。


6.查找浏览器缓存时的顺序是：Service Worker -> Memory Cache -> Disk Cache -> Push Cache
·Service Work
  是运行在浏览器背后的独立线程，一般可以实现缓存功能，使用Service worker的话，传输协议必须是https，因为service worker中涉及到了请求拦截，所以必须使用https协议来保障安全。service worker的缓存与浏览器内其他内建的缓存机制不一致，他可以让我们自由的控制缓存哪些文件、如何读区缓存、并且缓存是持续性的

  ·Memory cache
  内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式，脚本，图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭tab页面，内存中的缓存也就被释放了

·Disk cache
  存储在硬盘中的缓存，读取速度慢点，但是什么都能够存储到磁盘中，比memory cache 胜在容量和存储时效上。

  在所有的浏览器缓存中，disk cache覆盖面基本上是对大的。它会根据http header中的字段判断哪些资源需要缓存等。并且即使在跨站点的情况先，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自于Disk cache.

·prefetch cache
  link标签上带了prefetch ，再次加载会出现
  prefetch是预加载的一种方式，被标记为prefetch的资源，将会被浏览器在空闲时间加载。

·Push cache
  名叫推送缓存，是http2中的内容，当以上三种缓存都没有命中时，他才会被使用。他只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在chrome浏览器中只有5分钟左右，同时他也并非严格执行http头中的缓存命令

#### 协商缓存
1.定义：
  协商缓存就是强缓存失效后，浏览器携带缓存表示想服务器发送请求，有服务器根据缓存标识来决定是否使用缓存的过程

2.主要有一下两种情况：
  1.协商缓存生效，返回304
  2.协商缓存失效，返回200和请求的结果

3.如何设置协商缓存？
  ·Last-Modifled/If-Modifled-Since
    Last-Modifled是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
    If-Modifled-Since是客户端再次发起该请求时，携带上次请求返回的last-modifled值，通过此字段值告诉服务器该资源上次请求返回的最后被修改的时间。服务器接收到该请求后，发现请求头含有if-modifled-since字段，则会根据if-modifled-since的字段值与该资源在服务器最后被修改的时间做对比，若服务器的资源最后被修改的时间大于if-modifled-snce的字段值，则重新返回资源，状态码为200，否则为304，代表资源无更新，可继续使用缓存资源。

  ·Etag/If-Node-Match
    ·Etag是服务器响应请求时，返回当前资源文件的一个唯一标识
    ·If-Node-Match是客户端再次发起请求时，携带上一次请求返回的唯一标识Etag的值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。


  Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。

#### 缓存方案
目前的项目大多使用这种缓存方式
  1.html使用协商缓存
  2.css，js，图片使用强缓存，文件名带上hash

#### 强缓存和协商缓存的区别？
强缓存不会发起请求到服务端，所以有时候资源更新浏览器不知道；协商缓存会发送请求到服务端，资源是否更新浏览器是知道的。

大部分web服务器都默认开始协商缓存。


### 什么是https？
https是http协议的扩展，使用了TLS和SSL对通信字段进行了加密，http+TLS/SSL = https

### https解决了什么问题？
由于http天生是明文传输的，在http的传输过程中任何人都有可能会获取传输的信息、或者修改请求，所以认为http是不安全的。
在http的传输过程中不会去验证双方的身份，因此http的信息交换双方就有可能遭到伪装。
https通过在http的基础上进行SSL加密并且会进行身份认证，使数据传输更加安全。

### http各版本的区别？
1. http0.9
- 只接受GET一种请求方法，并且不支持请求头
- 服务器只能返回HTML格式的字符串

2. http1.0
- 新增了请求方式POST、HEAD
- 支持请求头和响应头
- 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

3. http1.1
- 新增了PUT、DELETE、OPTION、PATCH四个请求方式
- 客户端请求的头信息新增了Host字段，用来指定服务器的域名。
- 支持文件断点续传

4. http2.0
二进制分帧、多路复用、头部压缩、服务器推送