#### 微信
#### 谈谈对keep-alive的理解
		1.定义
			keep-alive是一个抽象的组件，他本身不会渲染一个dom元素，也不会出现在父组件链中，使用keep-alive包裹动态组件，会缓存不活动的组件实例，而不是销毁他们
			
			
		2.特点
			·他是一个抽象的组件，自身不会渲染一个dom元素，也不会出现在组件的父组件链中
			·当组件在keep-alive内被切换，组件的activated和deactivated这两个生命周期钩子函数会被执行。组件一旦被缓存，再次渲染就不会执行created,mounted生命周期钩子函数。
			·要求同时只有一个子组件被渲染
			·不会再函数式组件中正常工作，因为他没有缓存实例
			
		2.用法
			·在动态组件中的应用
				<keep-alive :inclue="whiteList" exclude="blackList" :max="amount">
					<component :is="currentComponent" />
				</keep-alive>
				
			·在vue-router中的应用
				<keep-alive :inclue="whiteList" exclude="blackList" :max="amount">
					<router-view />
				</keep-alive>
				
			include定义缓存名单，exclude定义缓存黑名单
			max定义缓存组件上限，超出上限使用lur的策略置换缓存数据
			
		
		3.源码解析
			<!-- src/core/component/keep-alive.js -->
			export default{
				name:'keep-alive',
				
				abstract:true, //判断当前组件虚拟dom是否渲染成真实dom的关键
				
				props:{
					include:patternTypes, //缓存白名单
					exclude：patternTypes, //缓存黑名单
					max:[string,number], //混存的组件实例数量上限
				},
				
				created(){
					this.cache = Object.create(null) //缓存虚拟dom
					this.keys = [] //缓存的虚拟dom的键集合
				},
				
				destroyed(){
					for(const key in this.cache){ //删除所有缓存
						pruneCachEntry(this.cache,key,this.keys)
					}
				},
				
				mounted(){
					<!-- 实时监听黑白名单的变动 -->
					this.$watch('include',val => {
						pruneCache(this,name => matches(val,name))
					})

					this.$watch('exclude',val => {
						pruneCache(this,name => matches(val,name))
					})				
				},
				
				render(){
					const slot = this.$slots.default
					const vnode:VNode = getFirstComponentChild(slot); //找到第一个子组件对象
					const componentOptions:?VNodeComponentOptions = vnode && vnode.componentOptions
					
					if(componentOptions){ //存在组件参数
						<!-- check pattern -->
						const name:?string = getComponent(componentOptions) //组件名称
						const {include,exclude} = this;
						
						<!-- 条件匹配 -->
						if((include && (!name || !matches(include,name))) || (exclude && name && matches(exclude,name))){
							return vnode
						}
						
						
						const {cache ,keys} = this;
						
						<!-- 定义组件的缓存key -->
						const key:?string = vnode.key == null  ？ componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}`) : vnode.key 
						
						<!-- 已经缓存过的组件 -->
						if(cache[key]){
							vnode.componentInstance = cache[key].componentInstance
							remove(keys,key)
							keys.push(key) //调整key排序
						}else{
							cache[key] = vnode //缓存组件对象
							keys.push(key)
							
							if(this.max && keys.length > parseInt(this.max)){ //超过缓存数限制，将第一个删除
								pruneCacheEntry(cache,keys[0],keys,this._vnode)
							}
						}
					}
				vnode.data.keepAlive = true //渲染和执行被包裹组件的钩子函数需要用到
				}
				
				return vnode || (slot && slot[0])
			}
			
			·第一步：获取keep-alive包裹的第一个子组件对象及其组件名
			·第二步：根据设定的黑白名单进行条件匹配，决定是否缓存，不匹配直接返回组件实例，否则执行第三步
			·第三步：根据组件id和tag生成缓存key，并在缓存对象中查找是否已缓存过该组件实力。如果存在，直接取出缓存值并更新该key在this.keys中的位置，否则执行第四步
			·第四步：在this.cache对象中存储该组件实例并保存key值，之后检查缓存的实例数量是否超过max的设置值，超过则根据lru置换策略删除下标为0的实例。
			·第五步：将该组件实例的keepalive属性值设置为true。
			
		
		4.vue的渲染过程
			vue的渲染是从图中的render阶段开始的，但keep-alive的渲染是在patch阶段，这是构建组件shu5并将vnode转换成真正的dom节点的过程
		
			简单描述从render到patch的过程
				1.vue在渲染的时候先调用原型上的_render函数将组件对象转化为一个VNode实例；而_render是通过调用createElement和createEmptyVNode两个函数进行转化的。
				2.createElement的转化过程根据不同的情形选择new VNode或者是调用createComponent函数做VNode实例化
				3.完成VNode实例化后，这时候Vue调用原型上的_update函数把VNode渲染称为真实的DOM，这个过程又是通过调用_patch_函数完成的（这个就是patch阶段了）
				
		5.keep-alive组件的渲染
			keep-alive不会生成真正的dom节点
			
			export function initLifeCycle(vm:Component){
				const options = vm.$options
				
				<!-- 找到一个非abstract的父组件实例 -->
				let parent = options.parent
				if(parent && !options.abstract){
					while(parent.$options.abstract && parent.$parent){
						parent = parent.$parent
					}
					
					parent.children.push(vm)
				}
				vm.$parent = parent
			}
			
			vue在初始化生命周期的时候，为组件实例建立父子关系会根据abstract属性决定是否忽略某个组件。在keep-alive中，设置了abstract：true，那么vue就会跳过该组件实例。
			
			最后构建的组件树就不会包含keep-alive组件，那么由组件树渲染成的dom树自然也不会由keep-alive的相关节点
			
		6.keep-alive包裹的组件是如何使用缓存的？
			在patch阶段，会执行createComponent函数
			
			function createComponent(vnode,insertedVnodeQueue,parentElm,refElm){
				let i = vnode.data;
				if(isDef(i)){
					const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
					if(isDef(i = i.hook) && isDef(i = i.init)){
						i(vnode,false)
					}
					
					if(isDef(vnode.componentInstance)){
						initComponent(vnode,insertedVnodeQueue)
						
						insert(parentElm,vnode.elm,refElm) //将缓存的dom插入到父元素中
						
						if(isTrue(isReactivated)){
							reactivateComponent(vnode,insertedVnodeQueue,parentElm,refElem)
						}
						
						return true
					}
				}
			}
		
			·在首次加载被包裹组件时，由keep-alive.js中的render函数可知，vnode.componentInstance的值是undefined，keepalive的值是true,因为keep-alive组件作为父组件，他的render函数会先于被包裹组件执行，那么就只能执行到i(vnode,false)
			·再次访问被包裹组件的时候，vnode.componentInstance的值就是已经缓存的组件实例，那么会执行insert(parentElm,vnode.elm,refelm)逻辑，这样就直接把上一次的dom插入到了父元素中
			
#### scrollBehavior
	接收to和from路由对象。第三个参数savedPosition当且仅当popstate导航（通过浏览器的前进/后退按钮触发）时才可用。
	
	const router = new VueRouter({
		mode:'hash',
		routes,
		scrollBehavior(to,from ,savedPostion){
			if(savedPostion){
				return new Promise((resolve, reject) => {
				      setTimeout(() => {
				        resolve(savedPosition)
				      }, 20)
				    })
			}else {
				if(from.meta.keepAlive){
					from.meta.scrollTop = document.doucmentElement.scrollTop
				}
			}
			
			return {
				x:0,
				y:to.meta.scrolltop || 0
			}
		}
	})
	
	export default router

#### keep-alive如何清除缓存
	
	就是写了一个mixin
		const mixin = {
			beforeRouteLeave(t,from,next){
				if(to.name === 'addressLista'){
					from.meta.keepalive = true;
				}else {
					if(this.$vnode && this.$vnode.keepAlive){
						if(this.$vnode.parent && this.$vnode.parent.componentInstance && this.$vnode.parent.componentInstance.cache){
							if(this.$vnode.componentOptions){
								var key = this.$vnode.key === null ? this.$vnode.componentOptions.c + (this.$vnode.componentOptions.tag ? `::${this.$vnode.componentOptions.tage}` : '') : this.$vnode.key
								
								var cache = this.$vnode.parent.componentInstance.cache;
								var keys = his.$vnode.parent.omponentInstance.keys;
								
								if(cache[key]){
									if(keys.length){
										var index = keys.indexOf(key)
										
										if(index > -1){
											keys.split(index,1)
										}
									}
										
									delete cache[key]
								}
							}
						}
						
						from.meta.keepAlive = true;
					}
				}
				
				next()
			}	
		}
		
		
#### vue的源码分析
	从vue的源码来看，vue的双向绑定主要做了两件事
		1.数据劫持
		2.添加观察者
		
	数据劫持的源码实现：
		Object.defineProperty(obj,key,{
			enumerable:true,
			configurable:true,
			get:function reactiveGetter(){
				const value = getter ? getter.call(obj) : val
				if(Dep.target){
					dep.depend()
					
					if(childOb){
						childOb.dep.depend();
					}
					
					if(Array.isArray(value)){
						dependArray(value)
					}
				}
				
				return value
			},
			
			set:function reactiveSetter(newVal){
				const value =getter ? getter.call(obj) :val
				
				if(newVal === value || (newVal !== newVal && value !== value)){
					return 
				}
				
				if(setter){
					setter.call(obj,newVal)
				}else{
					val = newVal
				}
				
				childOb = !shallow && observe(newVal)
				dep.notify()
			}
		})
		
		这里无非就是劫持了对象的get和set方法，在所有代理的属性的get方法中，当dep.target存在时候会调用dep.depend()
		
#### vueX的是实现原理
	定义：
		vuex是一个专为vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态
#### vuex解决了什么问题？
	·多个组件依赖于同一状态，对于多层嵌套的组件的传参将会非常的复杂，并且对于对于兄弟组件间的状态传递也无能为力
	·来自不同组件的行为需要更改同一状态，以往采用福子组件直接引用或者是通过时间来变更同步状态。
	
#### vuex的5个核心属性是什么
	1.state：
	2.getters：
	3.mutations：
	4.actions：
	5.modules：
	
#### vuex中的状态存储在哪里？怎么改变它？
	存储在state里面，改变vuex中的状态的唯一途径就是显示的提交mutation
	
#### vuex中的状态是对象时，使用时要注意什么？
	因为对象是应用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许的，所以先用深度克隆复制对象以后，在修改
	
#### 怎么在组件中批量使用vuex的state状态？
	使用mapState:可以辅助获得多个state的值，利用对象展开运算符将state混入computed对象中
	
	import { mapState } from 'vuex'
	default export {
		computed:{
			...mapState(['price','number'])
		}
	}
	
#### vuex中要从state总派生出一些状态，且多个组件使用他，该怎么做？
	使用getter属性，相当于vue中的计算属性computed，只有原状态改变派生状态才会改变。
	
	getter接收两个参数，第一个state，第二个是getters（可以使用访问其他的getter）
	
	const store = new.Vuex.store({
		state:{
			price:10,
			number:10,
			discount:0.7
		},
		
		getters:{
			totoal:state => {
				return state.price *state.number
			},
			discountTotal:(state,getters) => {
				return state.discount * getters.totoal
			}
			
		}
	})
	
	组件中引用:（然后再组件中可以计算属性computed通过this.$store.getters.total这样来访问这些派生状态）
	computed:{
		total(){
			return this.$store.getters.total
		},
		discountTotal(){
			return this.$store.getters.discountTotal
		}
	}
		
#### 怎么通过getter来实现组件内可以通过特定条件来获取state的状态
	通过让getter返回一个函数，来实现给getter传参，然后通过参数来进行判断从而获取state中满足要求的状态。
	
	const store = new Vuex.store({
		state:{
			todos:[
				{id:1,text:'...',done:true},
				{id:2,text:'...',done:false}
			]
		},
		
		getter:{
			getTodoById:(state) => (Id) => {
				return state.todos.find(item => item.id === Id)
			}
		}
	})
	
	computed:{
		getTodoById(){
			return this.$store.getters.getTodoById
		},
	},
	
	mounted(){
		console.log(this.getTodoById(2).done);
	}
	
#### 怎么在组件中批量获取vuex中的getter属性
	使用mapGetters辅助函数，利用对象展开运算符将getter混入computed对象中
	
	import { mapGetters } from 'vuex'
	export default {
		computed:{
			...mapGetters(['total','discountTotal'])
		}
	}
	
#### this.$store.commit('SET_NUMBER',10),修改state
#### mutation必须是同步函数
#### 在组件中多次使用mutation，怎么写比较方便
	使用mapMutations
	
#### vuex中的actions和mutation有什么区别
	1.action提交的是mutation，而不是直接变更状态。mutation可以直接变更状态
	2.actin可以包含任意异步操作，mutation只能是同步操作
	3.提交方式不同
		action用的是this.$store.dispatch('ACTION_NAME',data)来提交
		mutation是用this.$store.commit('MUTATION_NAME',data)来提交
	4.接受的参数不同
		mutation第一个参数是state，而action的第一个参数是context，其中包含了
		{
			state, //等同于`store.state`
			rootState, //等同于 store.state
			commit, //等同于store.commit
			dispatch,//等同于store.dispatch
			getters，//等同于store.getters，
			rootGetters //等同于
		}

#####  vuex中的action是异步的，如何知道action已经结束
	在action中返回一个promise，然后在提交的使用用then处理
	
#### 两个action，如何在一个action中调用另一个action，并且要等另一个完成后在进行其他的操作，如何处理
	利用async和await
	
#### 用过vuex中module,为什么使用，怎么使用
	因为使用单一状态树，应用的所有状态会集中到一个比较大的对象中，当应用遍的非常复杂的时候，store对象就有可能会变得非常的臃肿。所以将store分割成模块（module）.每个模块拥有自己的state，mutations，actions,getters,甚至是嵌套子模块，从上之下进行同样方式的分割。
	
#### 在模块中，getter和mutation和action中如何访问全局的state和getter？
	1.在getter中可以通过第三个参数rootState访问全局的state，可以通过第四个参数rootGetters访问到的getter
	2.在mutation中不可以访问到全局的state和getter，只能访问到局部的state。
	3.在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter

#### 前端浏览器缓存知识
	
	1.什么是浏览器缓存？
		当我们第一次访问网站的时候，电脑会把网站上的图片和数据下载到电脑上，当我们再次访问该网站时，网站就会从电脑中直接加载出来，这就是缓存
		
	2.优点
		·缓解服务器压力，不用每次都去请求某些数据
		·提升性能，打开本地资源肯定要比请求服务器快
		·减少宽带消耗，当我们使用缓存时，只会产生很小的网络消耗
		
	3.web缓存种类
		数据库缓存
		CDN缓存
		代理服务器缓存
		浏览器缓存
			定义：就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息
			种类：强缓存、协商缓存
			
			缓存位置一般分为4类：Service worker -> Memory Cache -> Disk Cache -> Push Cache
			
#### 强缓存
		定义:
			强缓存是当我们访问url的时候，不会像服务器发送请求，直接从缓存中读取资源，但是会返回200的状态码
			
		强缓存如何设置：
			我们第一次进入到页面中，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对浏览器资源进行缓存，如果响应头中的expires，pragma或者是cache-control字段，代表这是强缓存，浏览器会被资源缓存在memory cache或者是disk cache中。
			
			第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码304，不符合则服务器会返回全新的资源
			
		属性：
			·expires:是http1.0控制网页缓存的字段，值为一个时间戳，缺点是他判断是否过期是用本地时间来判断，本地时间是可以自己修改的。
			
			·cahce-control：是http1.1中控制网页缓存的字段，当cahche-control都存在时，cache-control优先级更高，主要取值为：
				public：资源客户端和服务器都可以缓存
				privte：资源只有客户端可以缓存
				no-chache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证
				no-store:不使用缓存
				max-age:缓存保质期	
				
	5.缓存位置
		存储图像和网页等资源主要缓存在disk cache，操作系统缓存文件等资源大部分都会缓存在memory cahce中。
				
			
	6.查找浏览器缓存时的顺序是：Service Worker -> Memory Cache -> Disk Cache -> Push Cache 
		·Service Work
			是运行在浏览器背后的独立线程，一般可以实现缓存功能，使用Service worker的话，传输协议必须是https，因为service worker中涉及到了请求拦截，所以必须使用https协议来保障安全。service worker的缓存与浏览器内其他内建的缓存机制不一致，他可以让我们自由的控制缓存哪些文件、如何读区缓存、并且缓存是持续性的
			
	   ·Memory cache
			内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式，脚本，图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭tab页面，内存中的缓存也就被释放了
		
		·Disk cache
			存储在硬盘中的缓存，读取速度慢点，但是什么都能够存储到磁盘中，比memory cache 胜在容量和存储时效上。
			
			在所有的浏览器缓存中，disk cache覆盖面基本上是对大的。它会根据http header中的字段判断哪些资源需要缓存等。并且即使在跨站点的情况先，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自于Disk cache.
			
		·prefetch cache
			link标签上带了prefetch ，再次加载会出现
			prefetch是预加载的一种方式，被标记为prefetch的资源，将会被浏览器在空闲时间加载。
			
		·Push cache
			名叫推送缓存，是http2中的内容，当以上三种缓存都没有命中时，他才会被使用。他只在会话中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在chrome浏览器中只有5分钟左右，同时他也并非严格执行http头中的缓存命令
			
#### 协商缓存
	1.定义：
		协商缓存就是强缓存失效后，浏览器携带缓存表示想服务器发送请求，有服务器根据缓存标识来决定是否使用缓存的过程
		
	2.主要有一下两种情况：
		1.协商缓存生效，返回304
		2.协商缓存失效，返回200和请求的结果
		
	3.如何设置协商缓存？
		·Last-Modifled/If-Modifled-Since
			Last-Modifled是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
			If-Modifled-Since是客户端再次发起该请求时，携带上次请求返回的last-modifled值，通过此字段值告诉服务器该资源上次请求返回的最后被修改的时间。服务器接收到该请求后，发现请求头含有if-modifled-since字段，则会根据if-modifled-since的字段值与该资源在服务器最后被修改的时间做对比，若服务器的资源最后被修改的时间大于if-modifled-snce的字段值，则重新返回资源，状态码为200，否则为304，代表资源无更新，可继续使用缓存资源。
			
		·Etag/If-Node-Match
			·Etag是服务器响应请求时，返回当前资源文件的一个唯一标识
			·If-Node-Match是客户端再次发起请求时，携带上一次请求返回的唯一标识Etag的值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

		
		Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。
			
#### 缓存方案
	目前的项目大多使用这种缓存方式
		1.html使用协商缓存
		2.css，js，图片使用强缓存，文件名带上hash
		
#### 强缓存和协商缓存的区别
	1.强缓存不发请求到服务器，所以有时候资源更新以后浏览器不知道。但是协商缓存会发送请求到服务器，所以资源是否更新服务器是知道的
	2.大部分web服务器默认都开启的协商缓存


#### 什么是https?
	http是一种超文本传输协议，他是一个传输文字，图片，音频，视频等超文本数据的约定和规范。
	https是在系统之间金总安全的交换信息，相当于在http中加入了一个secure的协议；是一个传输文字，图片，音频视频等超文本数据的约定和规范，
	
	https是http协议的一种扩展，使用了TLS和SSL对通信字段进行加密，也就是http+SSL(TLS) =https
				
#### https解决了什么问题
	因为http不安全，由于http天生的明文传输的特性，在http的传序过程中任何人都有可能从中获取，修改请求，所以认为http是不安全。在http的传输过程中不会验证通信方的身份，因此http的信息交换的双方就有可能遭到伪装，也就是没有用户验证；在http的传输过程中，接收方和发送方都不会进行验证报文的完整性，
	
#### HTTPS做了什么
	1.加密
	2.数据一致性
	3.身份认证
	
#### 什么是SSL/TLS
	TLS是SSL的后续版本，他们是用于互联网之间用于身份验证和加密的一种协议
	
#### HTTPS的内核是http
	https并不是一项新的应用层协议，只是http通信接口部分由ssl和tl替代而已，通常情况下http会直接和tcp通信，在https中，会先变成和ssl进行通信，然后在有ssl和tcp进行通信
	
	
#### promise、promise chain
	https://juejin.cn/post/6844904023988895757
	
	.catch可以通过返回一个常规值来覆盖错误
	
#### 实现一个有并行限制的promise调度器
	题目：
		js实现一个带有并发限制的异步调度器Scheduler，保证同时运行的任务最多两个。
		
	class Scheduler {
		constructor(){
			this.queue = [];
			this.maxCount = 2;
			this.runCounts = 0;
		}
		
		add(promiseCreator){
			this.queue.push(promiseCreator)
		}
		
		taskStart(){
			for(let i = 0; i <this.maxCount ;i ++ ){
				this.request()
			}
		}
		
		request(){
			if(!this.queue || !this.queue.length || this.runCounts >= this.maxCount){
				return 
			}
			
			this.runCounts ++ ;
			
			this.queue.shift()().then(() => {
				this.runCounts--;
				this.request()
			})
		}
	}
	
	
	const timeout = time => new Promise((resolve,reject) => {
		setTimeout(resolve,time)
	});
	
	const scheduler = new Scheduler();
	
	const addTask = (time,order) => {
		scheduler.add(() => timeout(time).then() => console.log(order))
	}
	
	scheduler.taskStart()
	
#### 请实现一个cacheRequest方法，保证当前的ajax请求相同资源的时候，真实网络层，实际只发出了一次请求（假设已存在request方法用于封装ajax）
	const dict = new Map();
	
	const cacheRequest = (target) => {
		const cacheKey = target;
		
		const cacheInfo = dict.get(cacheKey);
		
		<!-- 无缓存的时候发起真实的请求 -->
		if(!cacheInfo){
			return handleRequest(target,cacheKey)
		}
		
		const status = cacheInfo.status
		<!-- 缓存的请求成功的时候，则返回 -->
		if(status === 'SUCCESS'){
			return Promise.resolve(cacheInfo.response)
		}
		
		<!-- 缓存的请求正在pending中，封装单独异步操作，加入队列 -->
		if(status === 'PENDING'){
			return new Promise((resolve,reject) => {
				cacheInfo.resolves.push(resolve);
				cacheInfo.rejects.push(reject)
			})
		}
		
		<!-- 缓存的请求失败的时候，重新发起请求 -->
		return handleRequest(target,cacheKey)
	}
	
	
	const setCache = (cacheKey,info) => {
		dict.set(cacheKey,{
			...(dict.get(cacheKey) || {}),
			...info
		})
	}
	
	const handleRequest = (url,cacheKey) => {
		setCache(cacheKey,{
			status:'PENDING',
			resolves:[],
			rejects:[]
		});
		
		const ret = request(url)
		
		return ret.then(res => {
			<!-- 返回成功，刷新缓存，广播并发队列 -->
			setCache(cacheKey,{
				status:'SUCCESS',
				response:res
			})
			
			notify(cacheKey,res);
			return Promise.resolve(res)
		}).catch(error => {
			setCache(cacheKey,{
				status:'FAIL'
			})
			
			notify(cacheKey,error);
			return Promise.reject(err)
		})
	}
	
	const notify = (cacheKey,value) => {
		const info = dict.get(cacheKey);
		
		let queue = [];
		
		if(info.status === 'SUCCESS'){
			queue = info.resolves
		}else if(info.status === 'FAIL'){
			queue = info.rejects
		}
		
		while(queue.length){
			const cb = queue.shift();
			cb(value)
		}
		
		setCache(cacheKey,{resolves:[],rejects:[]})
	}
	
	
	
	<!-- 简单解法 -->
	const dist = new Map();
	
	const cacheRequest = (url) => {
		if(dist.has(url)){
			return Promise.resolve(url)
		}else{
			return request(url).then(res => {
				dist.set(url,res);
				return res
			}).catch(err => {
				return Promise.reject(err)
			})
		}
	}
	
#### 实现一个批量请求函数multiRequest(urls,maxNum),要求如下：
	·要求最大并发数maxNum
	·每当有一个请求返回，就留下一个空位，可以增加新的请求
	·所有请求完成后，结果按照urls里面的顺序一次打印出来
	
	解答：
		const multiRequest = (urls = [],maxNum) => {
			<!-- 请求的总量 -->
			const len = urls.length;
			
			<!-- 根据请求数量创建一个数组来保存请求的结果 -->
			const result = new Array(len).fill(false);
			
			<!-- 定义当前完成的数量 -->
			let count = 0;
			
			return new Promise((resolve,reject) => {
				<!-- 请求maxNum -->
				while(count < maxNum){
					next()
				}
				
				
				function next(){
					let current = count++;
					
					<!-- 处理边界条件 -->
					if(current >= len){
						<!-- 请求全部完成就将promise置为成功状态，然后将result作为promise值返回 -->
						！result.includes(false) && resolve(result)
						
						return 
					}
					
					const url = urls[current];
					fetch(url)
						.then(res => {
							result[current] = res;
							
							if(current < len){
								next()
							}
						})
						.catch(err => {
							result[current] = err;
							
							if(current < len){
								next()
							}
						})
				}
			})
		}
		
#### promise的题
	Promise.resolve().then(() => {
	    console.log(0);
	    return Promise.resolve(4);
	}).then((res) => {
	    console.log(res)
	})
	
	Promise.resolve().then(() => {
	    console.log(1);
	}).then(() => {
	    console.log(2);
	}).then(() => {
	    console.log(3);
	}).then(() => {
	    console.log(5);
	}).then(() =>{
	    console.log(6);
	})
	
	执行结果0、1、2、3、4、5、6
	
#### 什么是宏任务和微任务？
	1.在es6中宏任务被称为task，为人物被称为jobs
	2.宏任务是有浏览器，node等发起的，而微任务是由js自身发起的。
	
	宏任务和微任务的创建方式
		1.宏任务 setTimeout setInterval
		2.微任务：promise(.then/.catch/.finally) async/await
		
#### 如何理解script是一个宏任务呢？
	如果同时存在两个script代码块，首先绘制从第一个script代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列中，那么第一个代码块中的同步队列执行完成之后，首先会晴空微任务队列，在去开启第二个script代码块的执行。
	
#### 什么是promise A+规范
	目前我们使用的promise就是基于promise a+的规范来实现的
	
#### 手写一个promise
	class MyPromise{
		contructor(executor){
			<!-- exector是一个执行器，进入会立即执行 -->
			executor(this.resolve,this.reject);
		}
		
		status = 'pending';
		value = null;
		reason = null;
		onFulfilledCallback = [];
		onRejectedCallback = [];
		
		resolve = (value) => {
			if(this.status === 'pending'){
				this.status = 'fulfilled'	
				this.value = value
				while(this.onFulfilledCallback.length){
					this.onFulfilledCallback.shift()(value)
				}
			}
		}
		
		reject = (value) => {
			if(this.status === 'pending'){
				this.status = 'rejected'
				this.reason = value
				while(this.onRejectedCallback.length){
					this.onRejectedCallback.shift()(value);
				}
				
			}
		}
		
		then(onFulfilled,onRejected){
			const promise2 = new MyPromise((resolve,reject) => {
				if(this.status === 'fulfilled'){
					const x = onFulfilled(this.value)
					
					resolvePromise(x,resolve,reject)
				}else if(this.status === 'rejected'){
					onRejected(this.reason)
				}else if(this.status === 'pending'){
					this.onFulfilledCallback.push(onFulfilled) 
					this.onRejectedCallback.push(onRejected) 
				}
			})
			
			return promise2
		}
		
	}
	
	function resolvePromise(x,resolve,reject){
		if(x instanceof MyPromise){
			x.then(resolvereject)
		}else{
			resolve(x)
		}
	}
	
#### 立即resolve的promise对象，是在本轮事件循环结束时执行，不是马上执行，也不是在下一轮事件循环的开始执行。
#### resolve()的本质作用
	1.resolve()是用来表示Promise的状态fulfilled，相当于只是定义了一个有状态的promise，但是并没有调用他
	2.promise调用then的前提是promise的状态为fulfilled
	3.只有promise调用then的时候，then里面的函数才会被推入到为人物中

#### promise.resolve()方法的参数分为了四种情况
	1.参数是一个promise实例
		如果参数是一个promise的实例，则promise.resolve将不做任何修改、原封不动的返回这个实例
		
	2.参数是一个thenable对象
		thenable对象指的是具有then方法的对象，比如下面的对象
			let thenable = {
				then:function(resolve,reject){
					resolve(42)
				}
			}
		promise.resolve方法会将这个对象转为promise对象，然后立即执行thenable对象中的方法
		
	3.参数不是具有tehn方法的对象，或者根本不是对象
		如果参数是一个原始值，或者是一个不具有then方法的对象，则promise.resolve方法返回一个新的promise对象，状态为resolved
		
	4.不带有任何参数
		promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的promise
		
#### Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)
	promise.resolve()方法的参数如果是一个原始值，或者是一个不存在then方法的对象，则promise.resolve方法就会返回一个新的promise对象，状态为resolved，promise.resolve方法的参数，会同时传递给回调函数。
	
	then方法接收的参数是函数的时候，如果传递的并非是函数，它实际上会将其解释为then(null),这会导致promise的结果传递到下面
	
#### 红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，如何让三个等不间断的重复交替的亮？
	const light = (timer,cb) => {
		return new Promise((resolve,reject) => {
			setTimeout(() => {
				cb();
				resolve();
			},timer)
		})
	}
	
	const step = () => {
		Promise.resolve().then(() => {
			return light(3000,red)
		}).then(() => {
			return light(2000,yellow)
		}).then(() => {
			return light(1000,green)
		}).then(() => {
			step()
		})
	}
	
	step()
	
#### 实现mergePromise函数，把传进去的数组按照顺序先后执行，并且把返回的数据先后放到数组data中
	const timeout = ms => new Promise((resolve,reject) => {
		setTimeout(() => {
			resolve();
		},ms)
	})
	
	const ajax1 = () => timeout(2000).then(() => {
		console.log(1);
		return 1
	})
	
	const ajax2 = () => timeout(1000).then(() => {
		console.log(2);
		return 2
	})
	
	const ajax3 = () => timeout(2000).then(() => {
		console.log(3);
		return 3;
	})
	
	const mergePromise = ajaxArray => {
		// 保存数组中的函数执行后的结果
		var data = [];
		
		// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。
		var sequence = Promise.resolve();
		
		ajaxArray.forEach(item =>  {
		    // 第一次的 then 方法用来执行数组中的每个函数，
		    // 第二次的 then 方法接受数组中的函数执行后返回的结果，
		    // 并把结果添加到 data 中，然后把 data 返回。
		    // 这里对 sequence 的重新赋值，其实是相当于延长了 Promise 链
		    sequence = sequence.then(item).then(res =>  {
		        data.push(res);
		        return data;
		    });
		})
		
		// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，
		// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。
		return sequence;
	}
	
	mergePromise([ajax1,ajax2,ajax3]).then(() => {
		console.log('done');
		console.log(data) // [1,2,3]
	})
	
	<!--要求分别输出 -->
	1 -> 2 -> 3 -> done -> [1,2,3]
	
#### 有 8 个图片资源的 url，已经存储在数组 urls 中（即urls = ['http://example.com/1.jpg', ...., 'http://example.com/8.jpg']），而且已经有一个函数 function loadImg，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。
	let url = ['https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg', 'https://www.kkkk1000.com/images/getImgData/gray.gif', 'https://www.kkkk1000.com/images/getImgData/Particle.gif', 'https://www.kkkk1000.com/images/getImgData/arithmetic.png', 'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif', 'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg', 'https://www.kkkk1000.com/images/getImgData/arithmetic.gif', 'https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/29/166be40ccc434be0~tplv-t2oaga2asx-image.image'];
	
	const loadImg = (url) => {
		return new Promise((resolve,reject) => {
			const img = new Image()
			img.onload = () => {
				console.log('一张图片加载完成');
				resolve()
			}
			img.onerror = reject;
			img.src = url;
		})
	};
	
	const limitLoad = (urls,handler,limit) => {
		<!-- 对数组做一个拷贝 -->
		const sequence = [].concat(urls);
		let promises = [];
		
		<!-- 并发请求到最大数 -->
		promises = sequence.splice(0,limit),map((url,index) => {
			return handler(url).then(() => {
				return index
			})
		})
		
		<!-- 利用数组的reduce方法来以队列的形式执行 -->
		return sequence.reduce((last,url,currentIndex) => {
			return last.then(() => {
				<!-- 返回改变状态最快的promise -->
				return Promise.resolve(promises)
			}).catch(err => {
				console.error(err)
			}).then(res => {
				<!-- 用新的promise替换掉最快改变的状态的promise -->
				promises[res] = handler(sequence[currentIndex]).then(() => {return res})
			})
			
		},Promise.resolve()).then(() => {
			return Promise.all(promises)
		})
		
	}

	limitLoad(urls,loadImg,3)
	
	/*
	因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用
	
	limitLoad(urls, loadImg, 3).then(() => {
	    console.log('所有图片加载完成');
	}).catch(err => {
	    console.error(err);
	})
	*/
	
	
#### 事件循环机制
	1.浏览器中的事件循环
		定义：js代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序，还依靠任务队列来搞定另外一写代码的执行。整个执行过程称之为事件循环过程
		
		一个线程中，事件循环是唯一的，但是任务队列可以拥有多个，任务队列又可以分为宏任务（task）和微任务（jobs）
		
		(我们知道async隐式返回promise作为结果的函数，那么可以简单的理解为await后面的函数执行完成后，await会产生一个微任务)，但是我们要注意这个微任务产生的时间，他是执行完await之后，直接跳出了async函数，执行其他的代码，其他的代码执行完毕后，再回到async函数去执行剩下的代码，然后把await后面的代码注册到了微任务的队列中
		
#### 输入一个URL会发生什么？
	1.DNS域名解析（DNS服务器是高可用，高并发和分布式的）
		根DNS服务器：返回顶级域名dNS服务器的IP地址
		顶级域dns服务器：返回权威dns服务器的IP地址
		权威DNS服务器：返回相应主机的IP地址
	2.建立TCP链接，
		进行三次握手，建立tcp链接
			1.第一次握手：建立连接。客户端发送链接请求报文段。
			2.第二次握手：服务器收到syn报文段，并进行确认
			3.第三次握手：客户端收到服务器的SYN+ACK报文段。
			
		SSL握手
			1.第一阶段：建立安全能力包括协议版本会话id密码构件压缩方法和初始随机数
			2.第二阶段：服务器发送证书 迷药交换数据和证书请求，最后发送请求-相应阶段的结束信号
			3.第三阶段：如果有证书请求客户端发送此证书 之后可兑换发送迷药交换数据 也可以发送证书验证消息
			4.第四阶段：变更密码构件和结束握手协议
			
	3.发送http请求，服务器处理请求，返回响应结果
	4.关闭TCP链接
	5.浏览器渲染 
		1.构件dom树
		2.样式计算
		3.页面布局
		4.生成分层树
		5.栅格话
		6.显示

#### 进程和线程的区别
	一个程序至少有一个进程，一个进程至少有一个线程
	线程的划分尺度小于进程，使得多线程的并发行高
	进程在之心过程中拥有独立的内存但愿，而多个线程共享内存，从而极大的提高了程序的运行效率
	
	区别：
		每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，顺序执行序列和程序的出口。
		但是线程不能够独立执行，必须存在在应用程序中，由应用程序提供多个线程执行控制。
		
	从逻辑角度来看多线程的意义在于一个应用程序中，有多个执行部分可以同时执行，但操作系统并没有 将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配。
	
#### 排序
	1.快速排序
	2.冒泡排序
	3.选择排序
	4.插入排序
	5.归并排序

#### 从输入一个url地址到浏览器完成渲染的整个过程？
	1.浏览器地址栏输入url并回车
	2.浏览器查找当前url是否存在缓存，并比较缓存是否过期
	3.DNS解析url对应的ip
	4.根据ip建立tcp链接（三次握手）
	5.发送http请求
	6.服务器处理请求，浏览器接收http的响应
	7.浏览器解析并渲染页面
	8.关闭tcp链接（四次握手）
	
#### 什么是事件代理（事件委托）有什么好处？
	事件委托的原理：不给每个子节点设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点
	
	优点：
		1.减少内存消耗和dom操作，提高性能。每个事件处理函数，都是一个对象，多一个事件处理函数，内存中就会被多占用一部分的空间，如果要用事件委托，就会将所有的操作放到js中，只对他的父级进行操作，与dom的操作只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能
		2.动态绑定事件，因为事件绑定在父元素上，所以新增的元素也能触发同样的事件
		
#### addEventListener默认是捕获还是冒泡？
	默认是冒泡
	
	addEventListener第三个参数默认是false代表的是事件冒泡的行为。
	
	当是true的时候就是执行事件捕获的行为
	
#### css的渲染层合成是什么？浏览器如何创建新的渲染层？
	 在dom树中每个节点都会对应一个渲染对象，当他们的渲染对象处于相同的坐标空间（z轴空间）时，就会形成一个renderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成，从而正确处理透明元素和重叠元素的显示。对于有位置重叠的元素的页面，这个尤其重要，因为一旦图层的合并顺序出现错误，将会导致元素显示异常。
	 
#### 浏览器如何创建新的渲染层
	根元素document -> 有明确的定位属性（relative，fixed，sticky，absolute）-> opacity<1 -> 有css fliter（滤镜）属性 -> 有css mask(遮罩)属性 ->有css mix-blend-mode（设置图片与父元素进行混合）属性且值不为normal -> 有css tranform属性且值不为none -> backface-visiblity（隐藏被旋转的div元素的背面）属性为hidden -> 有css reflection(倒影)属性 ->有css column-count(将div中的文本分为三列)属性且值不为auto或者是有css column-width(列的宽度)属性且值不为auto -> 当前有对于opacity 、transform、filter、backface-fliter应用动画 -> overflow不为visible
	
#### webpack plugin和loader的区别
	·loader 
		用于对模块源码的转换、loader描述了webpack如何处理非js模块，并且在buld中引入这些依赖，loader可以将文件从不同的语言转换为js，或者将内敛图像转换为dataUrl。
		
	·plugin	
		目的在于解决loader无法实现的其他的事，他直接作用于webpack，扩展了它的功能。在webpack运行的生命周期中会广播很多的事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出的结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境的变量
		
#### apply call bind的区别
	·三者都可以改变函数的this对象的指向
	·三者第一个参数都是this要指向的对象，如果没有这个参数或者是参数为undefined或null，则默认指向全局window
	·三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入
	·bind是返回绑定this之后的函数，便于后面调用：apply、call则是立即执行
	·bind会返回一个新的函数，如果这个返回的新的函数作为构造函数创建一个新的对象，那么此时的this不再指向传入的bind的第一个参数，而是指向用new创建的实例

#### 举出闭包实际场景运用的例子
	1.比如常见的防抖/节流
		function debounce(fn,delay = 300){
			let timer; //闭包引用的外界变量
			return function(){
				const args = arguments;
				if(timer) clearTimeout(timer)
				
				timer = setTimeout(() => {
					fn.apply(this,args)
				},delay)
			}	
		}
	2.使用闭包可以在js中模拟块级作用域
		function outputNumber(count){
			(function(){
				for(var i = 0 ; i < count ; i ++ ){
					console.log(i);
				}
			})()
		}
		
	3.闭包可以用于在对象中创建私有变量
			var aaa = (function(){
				var a = 1;
				function bbb(){
					a++;
					console.log(a)
				}
				
				function ccc(){
					a++;
					conosle.log(a);
				}
				
				return {
					b:bbb,
					c:ccc
				}
			})();
			
			console.log(aaa.a) //undefined
			
			aaa.b() => 2
			aaa.c() => 3
			
			
#### css优先级是怎么计算的
	·第一优先级：！important会覆盖页面内任何位置的元素样式
	·内联样式：如style="color:green",权值为1000，
	·ID选择器，如#app，权值为0100
	·类，伪类、属性选择器，如.foo,:first-child,div[class="foo"]，权值为0010
	·标签，伪元素选择器，如div::first-line,权值为1
	·通配符、子类选择器、兄弟选择器，如*，>,+,，权值为0000，
	·继承的样式没有权值
	
#### http状态
	1.204状态码（无内容）服务器成功处理了请求，但是没有返回任何内容
	2.301(永久移除)重定向
	3.302（临时移动）
	4.304(未修改)自从上次请求后，请求的网页未修改过，服务器返回次响应时，不会返回网页内容
	5.400(错误请求)一般为参数错误
	6.401（未授权）请求要求身份验证
	7.403(禁止)服务器拒绝请求
	8.404(未找到)服务器找不到请求的网页
	
#### http2.0做了哪些改进3.0？
	1.http2.0特性如下		
		二进制分帧传输
		多路复用
		头部压缩
		服务器推进
		
	http3.0相对于http2.0是一种脱胎换骨的改变！
	http协议是应用层协议，都是建立在传输层之上的，我们也都是知道传输层上不只有tcp协议，还有udp协议，2.0和1.0都是基于tcp协议的，因此都会有tcp带来的硬伤以及局限性，而http3.0是建立于udp基础上的。
	
	2.http3.0特性如下
		链接迁移
		无对头堵塞
		自定义的拥塞控制
		前向安全和前向纠错
		
#### position有哪些值，作用分别是什么？
	1.static
		没有定位，是position的默认值，元素处于正常的文档流中，会忽略left，top，right，bottom和z-index的属性
		
	2.relative
		相对定位，是指给元素设置相对原本位置的定位，元素并不脱离文档流，一次元素原本的位置也会被保留，其他的元素的位置不会受到影响
		
	3.absolute
		绝对定位，子元素相对于父元素进行定位
	
	4.fixed
		总是相对于body进行定位。
		
	5.sticky
		在屏幕范围时，该元素的位置并不受定位影响，当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left，top等属性成固定位置的效果。
		
#### 垂直水平居中实现方式
	1.定宽定高
		1.绝对定位和负margin值
		2.绝对定位和transform（transform：translate(-50%,-50%)） (定宽高/不定宽高)
		3.绝对定位+left/right/top/bottom+margin（margin：auto）
		4.flex布局(display:flex;justify-content:center;align-items:center) (定宽高/不定宽高)
		5.grid布局+margin（display：grid+margin:auto）(定宽高/不定宽高)
		6.table-cell+vertical-align+inline-block/margin:auto (定宽高/不定宽高)
			.box{
				display:table-cell;
				vertical-align:middle;
			}
			
			.children-box{
				display:inline-block;/margin:auto
			}
			
	2.不定宽高
		1.grid+flex布局
			.box{
				displya:grid
			}
			.children-box{
				align-self:center;
				justify-self:center;
			}
		
#### grid布局
	grid布局的属性分为两类，一类是定义在容器上的，成为容器属性，另一类是定义在项目上的成为项目属性
	
	1.display:grid制定一个容器采用网格布局
	
	2.display:inline-grid；默认情况下，容器元素都是块级元素，但是也可以设置为行内元素
	
	注意设置为网格布局以后，容器子元素的float，display：inline-block，display:table-cell,vertical-align和 column-*等设置的都将失效
	
	3.grid-template-columns定义每一列的宽，grid-template-rows定义每一行的高
	
	4.repeat(重复的次数，重复的值/模式)
	
	5.auto-fill有时，单元格的大小是固定的，但是容器的大小不确定。如果写昂每一行/列尽可能多的容纳单元格，可以使用auto-fill表示自动填充
		grid-tempate-rows：repeat(auto-fill,100px)
		
	6.fr关键字 为了方便表示比例关系，网格布局提供了fr关键字，如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍
	
	7.minmax(最小值，最大值)函数产生一个长度范围，表示长度就在这个范围之间
	
	8.auto关键字表示由浏览器自己决定
	
	9.grid-row-gap设置行与行之间的间隔，grid-column-gap设置列与列之间的间隔
	
	10.grid-gap表示grid-row-gap和grid-column-gap的合写
		grid-gap:20px 20px;
		
	11.grid-auto-flow属性，默认值是row，即先行后列，也可以设置为column，变成先列后行
	
	12.justify-items属性设置单元格内容的水平位置（左中右），align-items设置单元格内容的垂直位置（上中下）
		start:对齐单元格的起始边缘
		end:对齐单元格的结束边缘
		center:单元格内居中
		stretch:拉伸，占满单元格的整个宽度
	
	13.place-item是justify-items和align-items的合并
	
	14.justify-content是整个内容区域在容器里面的水平位置，align-content是整个内容区域的处置位置
		start：对齐内容的起始位置
		end：对齐内容的结束位置
		center：容器内居中
		stretch：项目没有指定大小的时候拉伸占满整个容器
		spcace-around：每个项目两侧的间隔相等，所以，项目之间的间隔比项目与容器边框的间隔大一倍
		space-between:项目与项目的间隔相等，项目与容器边框之间没有间隔
		space-evenly:项目与项目的将额相等，项目与容器边框之间也是相同的长度的间隔
		
	15.place-content是justify-content和align-content的合并
	
#### vue的组件的通讯方式有哪些？
	1.props和$emit父组件想子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$Emit触发事件来做的
	2.$parent和$children获取当前组件的父组件和当前组件的子组件
	3.$attrs和$listeners  A->B->C.vue2.4开始提供$attrs和$listeners来解决这个问题
	4.$refs获取组件实例
	5.eventBus兄弟组件数据传递数据
	6.vuex状态管理
	
#### vue响应式原理
	整体思路就是数据劫持+观察者模式
	
	对象内部通过defineReactive方法，使用object.defineProperty将属性进行劫持，数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的dep属性，存放他所依赖的watcher，当属性变化后会通知自己对应的watcher去更新
	
	相关代码：
		class observer{
			<!-- 观测值 -->
			constructor(value){
				this.walk(value)
			}
			
			walk(data){
				<!-- 对象上所有属性依次进行观测 -->
				let keys = Object.keys(data);
				for(let i = 0 ; i < keys.length ; i ++ ){
					let key = keys[i];
					let value = data[key];
					defineReactive(data,key,value);
				}
			}
		}
		
		function defineReactive(data,key,value){
			observe(value) //递归的关键
			<!-- 如果value还是一个对象会继续走一遍defineReactive层层遍历知道value不是一个对象为止 -->
			Object.defineProperty(data,key,{
				get(){
					console.log('获取值')
					
					return value					
				},
				set(newValue){
					if(newValue === value) return 
					
					console.log('设置值');
					value = newValue
				}
			})
		}
		
		export function observe(value){
			<!-- 如果传过来的是对象或者是数组 进行属性劫持 -->
			
			if(Object.prototype.toString.call(value) === '[object Object]' || Array.isArray(value)){
				return new Observer(value)
			}
		}
		
#### vue nextTick的原理
	nextTick中的回调是在下次dom更新循环结束之后执行的延迟回调。在修改数据这之后立即使用这个方法，获取更新后的dom。主要思路就是采用微任务优先的方法调用异步方法去执行nextTick包装的方法
	
	let callbacks = [];
	let pending = false;
	
	function flushCallbacks(){
		pending = false;  //把标志还原为false
		
		<!-- 依次执行回调 -->
		for(let i = 0; i < callbacks.length; i ++){
			callbacks[i]();
		}
	}
	
	let timerFunc; //定义异步方法，采用优雅降级
	if(typeof Promise !== 'undefined'){
		<!-- 如果支持promise -->
		const p = Promise.resolve();
		timerFunc = () => {
			p.then(flushCallbacks)
		}
	}else if(typeof MutationObserver !== 'undefined'){
		<!-- MutationObserver主要是监听dom的变化，也是一个异步的方法 -->
		
		let counter = 1;
		const observer = new MutationObserver(flushCallbacks);
		const textNode = document.createTextNode(String(counter));
		observer.observe(textNode,{
			characterData:true,
		})
		
		timerFunc = () => {
			counter = (counter+1)%2
			textNode.data = String(counter)
		}
	}else if(typeof setImmediate !== 'undefined'){
		timerFunc = () => {
			setImmediate(flushCallbacks)
		}
	}else {
		timerFunc = () => {
			setTimeout(flushCallbacks,0)
		}
	}
	
	export function nextTick(){
		<!--除了渲染watcher,还要用户手动调用nextTick一起被收集到数组 -->
		callback.push(cb);
		if(!pending){
			pending = true;
			timerFunc()
		}
	}
	
#### vue diff算法的原理
#### 路由原理history和hash的两种路由方式的区别
	1.hash模式
		·location.hash的值实际就是url中#后面的东西，它的特点就是：hash虽然出现在url中，但是不会被包含在http请求中，对后端完全没有影响，因此改变hash不会重新加载页面
		·可以为hash的改变添加监听事件
			window.addEventListener("hashchange",funRef,false);
			
		每次改变hash，都会在浏览器的访问历史中增加一个记录
		
	2.history
		利用了HTML5中的pushState()和replaceState();
		这两个方法应用于浏览器的历史记录站，提供了历史记录进行修改的方法，这两个方法的特点就是：当调用他们修改浏览器历史记录栈后，虽然当前的url改变了，但是不会刷新页面，这就为但页面应用前端路由“更新试图但不重新请求页面”提供了基础。
		
#### 手写bind
	<!-- bind实现要复杂一些，因为他考虑的情况比较多，还要涉及到参数的合并（类似于函数的柯里化） -->
	Function.prototype.myBind = function(context,...args){
		if(!context || context === null) context = window
		
		<!-- 创造为一个的key值，作为我们构造context内部方法名 -->
		let fn = Symbol();
		context[fn] = this;
		let _this = this;
		
		<!-- bind的情况要复杂一点 -->
		const result = function(...innerArgs){
				<!-- 第一种情况：若是将bind绑定之后的函数作为构造函数，通过new操作符使用，则不传入this，而是this指向实例化出来的对象 -->
				<!-- new操作符的作用：this指向result实例对象，而result又继承了传入的_this根据原型链知识可以得出以下结论 -->
				if(this instanceof _this === true){
					<!-- 此时this指向result实例，这时候不需要改变this指向 -->
					this[fn] = _this;
					this[fn](...[...args,...innerArgs])
					
					delete this[fn]
				}else{
					<!-- 如果只是作为普通函数调用，this指向传入的context -->
					context[fn](...[...args,...innerArgs]);
					delete context[fn]
				}
		}
		
		result.prototype = Object.create(this.prototype);
		return result
	}
	
#### 手写promise.all和race
	<!-- 静态方法 -->
	static all(promiser){
		let result = [];
		let count = 0;
		
		return new Promise((resolve,reject) => {
			for(let i = 0 ;i <promiser.length ; i ++){
				Promise.resolve(promiser[i]).then(
				(res) => {
					result[i] = res;
					count++;
					if(count === promiser.length) resolve(result)
				},
				(error) => {
					reject(error)
				}
				)
			}
		})
	}
	
	<!-- 静态方法 -->
	static race(promiser){
		return new Promise((resolve,reject) => {
			for(let i = 0 ;i < promiser.length ; i ++){
				Promise.resolve(promiser[i]).then(
				(res) => {
					resolve(res)
				},(error) => {
					reject(error);
				})
			}
		})
	}
		
#### 手写-实现一个寄生组合继承
	function Parent(name){
		this.name = name;
		this.sayHi = () => {
			console.log('Hi');
		}
	}

	Parent.prototype.play = () => {
		console.log(222);
	}
	
	function Children(name){
		Parent.call(this);
		this.name = name;
	}
	
	Children.prototype = Object.create(Parent.prototype);
	Children.prototype.constructor = Children;
	
#### 手写-new操作符
	function myNew(fn,...args){
		let obj = Object.create(fn.prototype) //创建一个新对象，使用现有的对象来提供新创建的对象的_proto_
		let res = fn.call(obj,...args)
		if(res && (typeof res === 'object'  || typeof res === 'function')){
			return res
		}
		
		return obj
	}
	
#### 手写setTimeout模拟实现setInterval
	function mysetInterval(fn,time === 1000){
		let timer = null;
		let isClear = false;
		
		function interval(){
			if(isClear){
				isClear = false;
				clearTimeout(timer);
				return 
			}
			
			fn();
			timer = setTimeout(interval,time)
		}
		
		timer = setTimeout(interval,time)
		
		return () => {
			isClear = true;
		}
	}
	
#### 手写-发布订阅模式
	class EventEmitter{
		constructor(){
			this.events = {}
		}
		
		<!-- 实现订阅 -->
		on(type.callback){
			if(!this.events[type]){
				this.events[type] = [callback]
			}else{
				this.events[type].push(callback)
			}
		}
		
		<!-- 删除订阅 -->
		off(type,callback){
			if(!this.events[type]) return 
			
			this.events[type] = this.events[type].filter(item => item !== callback);
		}
		
		<!-- 只执行一次订阅事件 -->
		once(type,callback){
			function fn(){
				callback();
				this.off(type,fn)
			}
			
			this.on(type,fn)
		}
		
		<!-- 触发事件 -->
		emit(type,...rest){
			this.events[type] && this.events[type].forEach(fn => fn.apply(this,rest))
		}
	}
	
#### 手写-防抖节流
	<!-- 防抖 -->
		function debounce(fn,delay= 300){
			let timer;
			return function(){
				const args = arguments;
				if(timer) clearTimeout(timer)
				
				timer = setTimeout(() => {
					fn.apply(this,args)
				},delay)
			}
		}
		
	<!-- 节流 -->
	function throttle(fn,delay){
		let frag = true;
		return function(){
			if(!frag) return 
			frag = false
			timer = setTimeout(() => {
				fn();
				frag = true
			},delay)
		}
	}
	
#### 手写-将虚拟dom转化为真实的dom(类似于递归题)
	function _render(vnode){
		<!-- 如果是数字类型转化为字符串 -->
		if(typeof vnode === 'number'){
			vnode = String(vnode)
		}
		
		<!-- 如果是字符串类型直接就是文本的节点 -->
		if(typeof vnode === 'string'){	
			return document.createTextNode(vnode)
		}
		
		<!-- 普通dom -->
		const dom  = document.createElement(vnode.tag);
		if(vnode.attrs){
			<!-- 遍历属性 -->
			Object.keys(vnode.attrs).forEach(key => {
				const value = vnode.attrs[key];
				dom.setAttribute(key,value)
			})
		}
		
		<!-- 子数组进行递归遍历草做，这一步是关键 -->
		vnode.children.forEach(child => dom.appendChild(_render(child)));
		return dom
	}
	
#### 手写-实现一个对象的flatten方法
	题目描述
		const obj = {
			a:{
				b:1,
				c:2,
				d:{
					e:5
				}
			},
			b:[1,3,{a:2,b:3}],
			c:3
		}
		
		flatten(obj)的结果返回	
			{
				a.b:1,
				a.c:2,
				a.d.e:5,
				b[0]:1,
				b[1]:3,
				b[2].a:2,
				b[2].b:3,
				c:3
			}
	function isObject(obj){
		return typeof obj === 'object' && val !== null
	}
			
	function flatten(obj){
		if(!isObject(obj)){
			return 	
		}
		
		let res = {};
		const dfs = (cur,prefix) => {
			if(isObject(cur)){
				if(Array.isArray(cur)){
					cur.forEach((item,index) => {
						dfs(item,`${prefix}[${index}]`)
					})
				}else{
					for(let k in cur){
						dfs(cur[k],`${prefix}${prefix ? '.' : ''}${k}`)
					}
				}
			}else{
				res[prefix] = cur
			}
		}
		
		dfs(obj,'')
		
		return res
	}
	
#### 手写-判断字符串是否有效
	给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

	function isValid (s){
		if(s.length % 2 === 1){
			return false
		}
		
		const obj = {
			'{':'}',
			'(':')',
			'[':']'
		};
		
		let stack = [];
		for(let i = 0 ;i < s.length ; i ++ ){
			if(s[i] === '{' || s[i] === '(' || s[i] === '['){
				stack.push(s[i])
			}else{
				const cur = stack.pop();
				if(s[i] !== obj[cur]){
					return false
				}
			}
		}
		
		if(stack.length){
			return false
		}
		
		return true;
	}

#### 手写-查找数组公共前缀
	编写一个函数来查找字符串数组中的最长公共前缀
	
	function longestCommonPrefix(strs){
		if(strs.length === 0 || strs[0].length === 0) return ''
		
		const lengths = strs[0].length;
		let commonStr = '';
		
		for(let i = 0 ;i < lengths,i ++ ){
			commonStr = strs[0].slice(0,i+1);
			
			for(let j = 1, j <strs.length ; j ++ ){
				if(commonStr !== strs[j].slice(0,i+1)){
					return strs[0].slice(0,i)
				}
			}
		}
		
		return commonStr
	}
	
#### 手写-字符串最长不重复子串
	给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度
	function lengthOfLongesSubstring(){
		if(s.length === 0) return 0
		
		let left = 0;
		let right = 1;
		let max = 0;
		
		while(right <= s.length){
			let lr =s.slice(left,right);
			const index = lr.indexOf(s[right]);
			
			if（）
		}
	}

#### 