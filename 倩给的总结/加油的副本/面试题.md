#### 原型和原型链
原型的五条规则

所有的引用类型都可以自定义添加属性
所有的引用类型都有自己的隐式原型（proto）
函数都有自己的显式原型（prototype）
所有的引用类型的隐式原型都指向对应构造函数的显示原型
使用引用类型的某个自定义属性时，如果没有这个属性，会去该引用类型的__proto__（也就是对应构造函数的prototype）中去找

#### 作用域及闭包
变量提升
以下两种情况会进行提升：

变量定义
函数声明
函数声明先于变量声明

自由变量
作用域链，及自由变量的查找，找不到逐级向上找
闭包的两个场景
函数作为变量传递
函数作为返回值


#### this几种不同的使用场景

在构造函数中使用（构造函数本身）
作为对象的方法时使用（调用属性的对象）
作为普通函数时使用（window）
call，apply，bind（执行的第一个参数）

#### 事件流
	事件流是网页元素接收事件的顺序，"DOM2级事件"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。
	首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。
	虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。
	
#### var、let、const之间的区别

#### 使用箭头函数应注意什么？
1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）（2）不能够使用arguments对象（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数

#### Promise构造函数是同步执行还是异步执行，那么 then 方法呢？
promise构造函数是同步执行的，then方法是异步执行的

#### Promise 中reject 和 catch 处理上有什么区别
	reject 是用来抛出异常，catch 是用来处理异常reject 是 Promise 的方法，而 catch 是 Promise 实例的方法reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch网络异常（比如断网），会直接进入catch而不会进入then的第二个回调


#### setTimeout、Promise、Async/Await 的区别
事件循环中分为宏任务队列和微任务队列其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

#### promise有几种状态，什么时候会进入catch？
三个状态：
pending、fulfilled、reject
两个过程：
padding -> fulfilled、padding -> rejected当pending为rejected时，会进入catch

### 使用结构赋值，实现两个变量的值的交换
#### Vue 响应式原理
	
#### computed 和 watch 有什么区别及运用场景?

#### Vue 中的 key 到底有什么用？
虚拟dom

#### 闭包及应用：防抖和节流（节流内部实现）
#### 你对Vue生命周期的理解？
#### 组件keep-alive
#### v-if和v-show
####
