

#### scss的几大特征？
	1、可以使用变量 $color:red;
		如果变量需要镶嵌在字符串中，就必须用#{}来包裹；
	2、允许代码中使用算法；
	3、scss有两种注释方式
		标准的css注释 /* common*/，会保留到编译后的文件
		单行注释 //common 只保留在原文件中，编译后被省略；
		在/*后边加一个！表示重要的注释，即使是压缩模式，也会保留这行注释，通常可以用于声明版权信息；
	4、继承
		选择器继承 @extend .class
	5、mixin
		使用mixin定义一个代码块，使用@include 命令，调用@mixin
		强大之处在于，可以指定参数和缺省值
	6、高级的条件语法
		@if   {
			
		} @else {
			
		}
	7、自定义函数
		@function double($n){
			@return $n*2
		}
#### 什么是RESTful API?怎么使用？
	是一个api的标准，无状态请求；

#### $route和$router的区别
  $router为vue-router的实例，想要导航到不同的url上，这是用$router.push;
  $route为当前router跳转对象里面可以获取name,path,query,params

#### nextTick是做什么的
  $nextTick是在下次Dom更新循环结束之后延迟回调，修改数据之后使用$nextTick,则可以再回调中获取更新后的DOM

#### Vue组件data为什么必须是函数
  因为js本身的特性决定的，如果data是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时会影响到所有的vue实例数据。如果data是一个函数并放回出一个对象，那么每一个实例的data属性就是独立的，不会相互影响 
#### 什么是vue的计算属性？
	好处：
		1、使数据处理结构清晰
		2、依赖于数据，数据更新，处理结果自动更新；
		3、计算属性内部this，指向vue实例；
		4、在template调用时，直接写计算属性名即可；
		5、相比较methods来说，不管以来数据变不变，methods都会重新计算，但是以来数据不变的情况下，computed会从缓存中取结果；
#### 计算属性computed和事件methods有什么区别？
  computed：计算属性是基于他们的依赖来进行缓存的，只有他的相关属性发生改变的时候，才会重新计算求值
  methods：只要发生重新渲染，就会执行该函数
  watch：监听某一个值，只有这个值发生变化的时候才会执行对应的操作

  watch更加适用于监听某一个值发生变化并做出相应的操作，而computed适用于计算已经存在的值并返回结果

#### 对比jquery，vue有什么不同
  jquery更加注重视图，通过操作dom去实现逻辑渲染；vue更加关注数据层，通过数据双向绑定，减少dom操作。vue使用了组件化的思想，使项目更加清晰，耦合性低，提高了开发效率，方便重复利用

#### vue中怎么使用自定义指令
  全局自定义指令：vue.directive('focus',{
    inserted:function(el,binding){
      el.focus();
    }
  })

  局部自定义指令：directives:{
    focus:{
      inserted:function(el){
        el.focus();
      }
    }
  }

  其中bind和inserted：
    共同点：dom插入时都会调用，bind在inserted之前调用
    不同点：
        （1）bind时父节点为null
        （2）inserted时父节点存在
        （3）bind是在dom树绘制前调用的，inserted在dom树绘制之后调用

    自定义指令的钩子里面没有vue实例，this指向undefined；
#### keep-alive?
	keep-alive用来保存组件的渲染着状态的；
	keep-alive的生命周期：
		初次进入：created->mounted->activated,退出后触发deactiveted；
		再次进入：会触发activted，事件挂载等方法，只一次放在mounted里面，组件每次进入的方法放在activted里面
	如何清空无用的缓存？
		假设两个A、B两个页面全部都有缓存，
		（1）假如第一次进入A页面后退出，再次进入页面时，页面不会刷新。这和目前的逻辑不相符合，我们想要的结果是A页面前进后返回，页面保持不变，而不是退出后重新进入保持不变。
		（2）在进入过A页面后进入B页面，经测试后发现，B页面竟然会显示A页面的缓存，尽管url已经变化。
		为了解决这个问题，需要判断页面是在前进还是后退，在beforeEach钩子中添加代码：
			let toDepth = to.path.split('/').length;
			let fromDepth = from.path.split('/').length;
			if(toDepth < fromDepth){
				from.meta.keepAlive = false;
				to.meta.keepAlive = ture;
			}
#### v-if和v-show的性能消耗？
	v-if有较高的切换性能消耗，v-show有较高的初始性能消耗
#### vue-loader是什么？
	基于webpack的一个loader，解析和转换.vue文件，提取其中的逻辑代码script，样式代码style，以及html模版template，在分别把他们交给对应的loader去处理，核心作用就是提取。
#### 什么是webpack的loader？
	其实就是用来打包、转译js或css文件，简单来说就是把你写的代码转换成浏览器能够识别的代码；
#### vue.use的原理？
  用法：vue安装的组件类型必须是function或者是object；
  如果是个对象，必须提供install方法；
  如果是个函数，会被直接当做install函数执行；

vue提供的插件注册机制很简单，每个插件都需要实现一个静态的方法install，当我们执行vue.use注册插件的时候，就会执行install这个方法，并且在这个install方法的第一个参数我们可以拿到vue对象，这样的好处就是作为插件的编写方法不需要额外的去import vue了；

#### vue中怎么自定义过滤器
  可以用全局的方法vue.filter()注册一个自定义过滤器，他接受两个参数：过滤器ID和过滤函数。过滤器函数以值为参数，返回转换后的值

  vu.filter('reserve',(val) => {
    return val.split(',').reserve().join('')
  })
  
#### vue等单页应用的优缺点？
  优点：良好的交互体验、良好的前后端分离模式、减轻服务器的压力
  缺点：seo的难度高、初次加载耗时多

#### vue-router有哪几种导航钩子？
  1.全局导航钩子：router.beforeEach(),router.afterEach()
 <!-- 2.组件内的钩子：beforeCreated（），created（），beforeMount（），Mounted（），beforeUpdate（），update（），beforeDestory（），destoryed（）； -->
  3.单独路由独享组件钩子：beforeEnter
  4.组件级钩子：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave

#### vue中如何在url上面传值？
	1.直接在path后面添加简单的动态参数，可以用this.$router.params来获取；
	2.在标签内容中添加，如果使用path，则只能使用query，如果使用params，则只能使用name；
#### vuex是什么？怎么使用？那种场景使用他？
  vuex是状态管理器，帮助我们管理共享状态，也就是管理全局变量；
  state：存储状态，也就是变量
  getters：派生状态，也就是set，get中的get，和vue的computed差不多
  mutations：提交状态修改，不支持异步操作，第一个参数默认为state，外部调用方式为this.store.commit('方法名‘，参数)
  actions：支持异步操作，第一个参数默认为是和store具有相同属性的对象，外部调用方式为this.store.dispatch('方法名'，参数)
  modules：store的子模块，内容就相当于是store的一个实例，调用方法和前面介绍的相似，只要加上当前子模块名就可以

#### vue中的mixin和extend的区别？
    mixins为全局注册混合对象，会影响到所有之后创建的vue实例
    vue.extend是对单个实例进行扩展
    mixins：混合对象的钩子将在组件自身钩子之前调用，meothods，componets，directives将被混合为同一个对象，两个对象的键名冲突时，取组件（而非mixins）对象的键值对；

#### vue-router的实现原理？
  单页面的原理：js会感知url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂靠在当前页面，也可以判断当前页面中的某血元素是否显示或者是隐藏，这样每次跳转就不需要请求新的html文件
  原理就是更新视图并不请求新的页面
  
#### 指令定义函数提供了几个钩子函数(可选)：
	1. bind：只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作；
	2. inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在与document中）；
	3. update:被绑定元素所在模版更新时调用，而不论绑定绑定值是否发生变化。通过比较更新前后的绑定值。
	4. componentUpdated:被绑定元素所在模版完成一次更新周期时调用；
	5. unbind：只调用一次，指令与元素解绑时调用。
	
#### axios的作用？
	vue中的ajax，用于向后台发起请求。
	特点：
		3.支持promise api；
		4.支持拦截请求和响应；
		5.转换请求数据和响应数据；
		6.可以取消请求
#### v-el的作用？
	提供一个在页面行已经存在 DOM元素作为vue实例挂载的目标
#### 列举http请求中常见的请求方式？
	1、get：向特定的路径资源发送请求，数据暴露在url上面；
	2、post：向特定的路径资源请求数据，数据包含在请求体中；
	3、options：返回服务器针对特定资源所支持的http请求方法，允许客户端查看，测试服务器性能；
	4、put：从客户端向服务器传送的数据取代指定的内容；
	5、delete：请求服务器删除指定的页面；
#### 什么是前端工程化？
  前端工程化是使用软件工程技术和方法来进行前端开发流程，技术，工具，经验等规范化，标准化，其目的就是为了提高效率和降低成本；

#### 如何做到“前端工程化”？
  前端工程化主要应该从：模块化，组件化，规范化，自动化四个方面考虑；

  模块化：就是将一个大文件拆分成项目依赖的小文件，再进行统一的拼接和加载；
    js模块化；用webapck+babel将所有的模块打包成一个文件同步加载，也可以达成多个chun异步加载；
    css模块化；vue的scoped style算是一种；
    资源的模块化：  
      依赖关系单一：所有的css和图片资源的依赖统一走js路线，无需额外处理css预处理的问题；
      资源处理集成化：使用loader对各个资源进行统一处理；
  组件化：从uI拆分下来的每个包含模版+样式+js的功能完备的结构单元，我们诚挚为组件；
  规范化：
    目录结构的指定
    编码规范；
    前后端接口规范；
  自动化：
    自动化部署；
    自动化构建；
    自动化测试；


#### 如何优化单页应用首屏加载速度慢的问题？
  1、将公用的js库通过script标签外部引入，减少app.bundle的大小，让浏览器并行下载资源文件，提高下载速度
  2、在配置路由时，页面和组件使用懒加载的方式进行引用，进一步缩小app.bundle的体积，在调用某个组件时在加载对应的js文件
  3、如果使用ui框架的时候我们可以按需加载；
  4、图片进行压缩上传到cdn上面，这样能够极大地减轻服务器的压力；

#### 前端如何优化网站性能？
  1.减少http的请求量（合并css和js文件，图片精灵，懒加载）
  2.控制资源文件加载的优先级
  3.利用浏览器缓存（浏览器缓存是将网络资源存储到本地，等待下次请求该资源的时候，如果资源已经存在就不需要到服务器中重新请求该资源，直接在本地读取该资源就可以了）
  4.减少重排：
  （重排是指某些元素的变化影响到了元素布局，浏览器则抛弃原有属性，重新计算；
	重绘是指dom元素的属性变化时，浏览器会重新render响应的属性；
	如何减少重排：
		1、dom的多个读操作或者是多个写操作应该放到一起
		2、不要一条条的改样式，而是通过class这种来修改样式
		3、position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。
		4、尽量使用代码片
	）
  5.减少dom操作
  6.图标尽量使用iconfont
#### 前端为什么要使用浏览器缓存？
	1、减少用户的等待时间，提升用户体验；
	2、减少网络带宽的消耗；
	3、降低服务器的压力；

#### 前端如何实现浏览器缓存？
	2、Cache-Control：max-age表示缓存资源的最大生命周期，单位是秒，所以Expires  结合 Cache-Control 一起使用，大型网站中一般比较适用
前端缓存一般是在对css，js，image等进行缓存
  （1）Expires服务器端设置，表示该资源的过期时间，会有弊端，客户端时间和服务器时间不一致的问题。
  （2）cache-control:描述一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断的，所以相对于expires，cache-control的缓存更加有效安全一些；值包含：public、private、no-cache、no-store、max-age...
      no-cache：指示请求或相应消息不能缓存，该选项并不是说可以设置“不缓存”，而是需要跟服务器确认
      no-store：在请求消息中发送将使得请求和相应消息都不实用缓存，完全不存下来
      max-age：max-age表示缓存资源的最大生命周期
  （3）last-modifed和etag标头：这些标头可用于指定浏览器应如何确定用于缓存文件是否相同。在last-modifed标头中指定的是日期，而在etag标头中指定的则可以是唯一表示资源

	方法：
		1、通过HTTP的META设置expires和cache-control
			<meta http-equiv="Cache-Control" content="max-age=7200" />
			<meta http-equiv="Expires" content="Sun Oct 15 2017 20:39:53 GMT+0800 (CST)" />
		2、apache服务器配置图片，css，js，flash的缓存
#### 网页从输入网址到渲染完成经历那些过程
  （1）输入网址
  （2）发送到dns服务器，并获取域名对应的web服务器的ip地址
  （3）与web服务器建立tcp链接
  （4）浏览器向web服务器发送http请求
  （5）web服务器响应请求，并返回指定的url的数据
  （6）浏览器下载web服务器返回的数据以及解析html文件
  （7）生成dom树，解析css和js，渲染页面，直至完成

#### 什么是webpack？
  webpack是模块打包机，分析项目结构，找到一些浏览器不能直接运行的扩展语言，并将其转换和打包为合适的格式供浏览器使用；

#### XMLHttpRequest状态码的意思？
  0-->未初始化，还没有调用send()方法
  1-->载入，已经调用了send方法，正在发送请求
  2--> 载入完成，send方法执行完成，已经接受到全部相应内容
  3-->交互，正在解析相应的内容
  4-->完成，相应内容解析完成，可以在客户端调用

#### call()和apply()的区别
  调用一个对象的一个方法，用另一个对象替换当前对象
	相同点：调用一个对象的一个方法，用另一个对象替换当前对象
	不同点：apply最多只能接收两个参数
			call可以接受多个参数
#### ajax中的get和post请求的方式的区别？
    1.get在浏览器回退时无害的，而post会再次提交请求
    3.get请求只能进行url的编码，而post支持多种编码格式
    4.get请求参数会完整保留在浏览器中，而post的参数不会被保留
    5.get请求参数的长度是有限制的，而post没有参数长度的限制
    6.get比post不安全，因为参数会直接暴露在url上，所以不能用来传递敏感信息





#### 什么是websocket？
  websocket是H5的一个新的协议，它允许服务器向客户端传递信息，实现浏览器和客户端的双向通信，弥补了http不支持常链接的问题；
#### websocket是一个什么样的协议，具有什么优点？
 首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说
 
 HTTP的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次HTTP请求就结束了。
 
 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起
   
   优点：解决了信息同步上面的问题；还有服务器的消耗问题
#### 为什么你们的项目中会使用websocket？
  当我们在处理页面数据自动更新的时候，在使用js不断的请求服务器，查看是否有新数据，如果获取到新的数据，就要对页面中新的数据进行更新，但是当页面长时间没有更新数据时，就存在资源浪费的情况，所以才决定使用websocket来解决问题；

#### websocket和scoket的区别是什么？
  socket是应用层于tcp/IP协议通信的中间软件抽象层，而websocket是一个完成的应用层协议

#### http于webscoket的区
  http协议是短链接，因为请求之后就会关闭链接，下次请求数据，需要在打开链接，websocket协议是一种长链接，只需要通过一次请求来初始化链接，然后所有的请求和响应都是通过这个tcp链接进行通信的。

#### ES6新增的特性
  （1）let声明变量和const声明常量，两个都有块级作用域；ES5中是没有块级作用域的，并且var存在变量升级的作用，在let中，使用的变量一定要进行声明；
  （2）es6中的函数定义不再使用function，而是利用箭头来定义的
  （3）模版字符串
  （4)es6中的解构赋值
  （5）import，export导入导出：将js代码分割成不同功能的小块进行模块优化，将不同功能的代码分别写在不同文件中，各个模块只需要到处公共接口部分，然后痛殴模块的倒入方式可以在其他的地方使用
  
  （6）
	1、set的内部是用Object.is()来判断两个数据项是否相等的，唯一不同的是+0和-0在set内部被认定为相等的；
	set的方法：
		let set = new Set();
			1.set.add()  添加
			2.set.has()  检查某个值是否在这个set里面
			3.set.delete() 删除某个值
			4.set.clear() 清空set所有元素
			5.set.forEach((value,key,ownerSet) => {
				value -> 元素值
				key -> 元素索引
				ownerSet -> 将要遍历的对象
				其中set的value和key是一样的，为了保持一致
			})
			6.set.keys();set.values();set.entries();
			7.将set转化为数组[...set]，或者是Array.from(set)
  （7）
	  1.map是es6中新增的数据类型，类似于对象，但是普通对象的key必须是数字或者是字符串，map的key可以是任何的数据类型
		map的方法：
			let map = new Map();
			
			1、map.size() 获取成员的数量；
			2、map.set(key,value) 设置成员key和value；
			3、map.get(key) 获取成员属性值；
			4、map.has(key) 判断出成员是否存在；
			5、map.delete(key) 删除某个成员
			6、map.clear() 清空所有成员；
		map实例的遍历方法：
			1、keys() 遍历所有的键名
			2、values() 遍历所有的键值
			3、entries() 所有成员的遍历器
			4、forEach() 遍历map的所有成员
  
  （7）...展开运算符：可以将数组或者是对象里面的值展开；
  （8）class类的继承
      <!-- 子类使用super关键字访问父类的方法 -->
        class Father{
          constructor(x,y){
            this.x = x;
            this.y = y;
          }
          sum(){
              console.log(this.x + this.y)
          }
        }
        <!--  子类继承父类-->
        class Son extends Father{
          constructor(x,y){
            <!-- 使用super调用父类中的构造函数 -->
            super(x,y) //实际上就是调用父类的构造函数
            this.x = x;
            this.y = y;
          }
        }
        <!-- 继承中，如果实例化子类输出一个方法，先看子类有没有这种方法，如果有就先至系女子类的 -->
        <!-- 继承中，如果子类里面没有，就去查找父类里面有没有这个方法，如果有就执行父类的 -->
        <!-- 如果子类想要继承父类的方法，同时在自己内部扩展自己的方法，利用super调用父类的构造函数，super必须在子类this之前调用 -->
    (9)对字符串做了一些升级，字符串可以被for...of循环，includes(),repeat(),startsWith
	(10)对数组进行了哪些优化，数组的结构和赋值，扩展运算符，方法find(用于找到符合条件的第一个数组成员)，findIndex(找到第一个符合条件的数组成员的索引)，includes(查找数组中是否包含该成员)
	（11）对number进行了一些优化，Number.isNaN于isNaN最大的区别是：number.isnan不存在类型转化的问题；
	（12）对对象进行了那些优化，解构和赋值，扩展运算符，object.assgin用于对象的赋值；object.is用于比较两个对象是否相同；
	（13）对function做了那些升级，箭头函数、函数的形参给定默认值
    this的指向问题：
		1、普通函数this指向的是window
		2、对象函数调用，那个函数调用this就指向哪里；
		3、构造函数调用，this指向的是new出来的实例
		4、定时器里面的this，指向window
		5、箭头函数里面的this不指向window，而是调用者
      constructor中的this指向的是new出来的实例对象；
      自定义的方法，一般也指向new出来的实例对象；
      绑定事件之后this指向的就是出发事件的事件源
    
  （9）async，await：使用async/await，搭配promise，可以通过编写同步的代码来处理一步流程，提高代码的间接性和可读性，其中async用于声明一个function是异步的，而await用于等待一个异步的方法执行完成；
  （10）symbol：是一种基本类型，symbol通过调用symbol函数产生，他接受一个可选明子参数，该函数放回的symbol、是唯一的，这个东西是可以共享的，在创建的时候会检查全局是否存在这个key对应的symbol，如果存在就直接返回这个symbol，如果不存在就会查u那个教案，并且全局注册；不可以进行强制转化；
#### 日常开发中，有那些值得用es6去改进的编程格式？
	1、用箭头函数、let代替var，使用结构和赋值来给对象命名或取值、模版字符串、class代替传统的函数、模块化开发，使用export和import
#### es6的class和构造函数的区别？
	1、默认是严格模式；
	2、不存在提升（类不存在变量提升）
	3、方法默认是不可枚举的；
	4、可以继承静态方法；
	5、class必须使用new来调用；
	
#### var，let,const之间的区别
  var可以重复声明变量，而let不可以重复声明变量；
  let是块及作用域；
  var存在变量提升，而let不存在变量提生；
  const声明之后必须赋值；
  const用于定义常量；

#### 箭头函数你应该注意什么？
  （1）this不再指向windows，而是父级；
  （2）不能用作构造函数；
  （3）是不需要function关键字来创建函数；

#### 介绍一下set和map的区别
  应用场景：set用于数据重组，map用于数据存储
  set：
  （1）成员不能重复
  （2）只有键值没有键名，类似数组
  （3）可以遍历，用keys(),values(),entries(),方法有add，delete，has，clear；
  map：
  （1）本质上就是键值对的集合，类似集合；
  （2）可以遍历，可以跟各种数据格式进行转化；
#### es6怎么写class，为何会出现class？
  es6中的class可以看作是一个语法糖，他的绝大部分功能es5都是可以实现的，新的class写法指示让对象原型的写法更加清晰
  class Ftaher{
    constructor(x，y){
      this.x = x;
      this.y = y;
    }
  }

#### setTimeout、promise、async/await的区别？
	promise的构造函数是同步执行的，.then()是异步执行的；
  　事件循环中分为宏任务队列和微任务队列
 
  　　其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行
  
  　　promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行
  
  　　async函数表示函数里面可能会有异步方法，await后面跟一个表达式
  
  　　async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行



### object.keys和reflect.ownKeys的区别
object.keys列举可以枚举的建；
reflect.ownKeys都可以；

#### promise中的reject和catch处理上有什么区别？
  reject是用来抛出异常，catch是用来处理异常的；
  reject是promise的方法，而catch是promise的实例方法；
  reject后的东西，一定会进入then中的第二个回调，如果then中没有第二个回调就会进入catch；
  网络呢异常等，会直接进入ctahc，而不会进入then；

#### forEach,for in for of三者的区别
  forEach更多的是用来遍历数组的；
  for in 一般常用来遍历对象或者是json；
  for of数组对象都可以遍历；
  for in 循环出来的是key，for of 循环出来的是value

#### forEach和map的区别？
  相同点：
    都是循环遍历数组中的每一项；
    只能遍历数组；
    匿名函数中的this，都指向window；
    都支持三个参数：item（每一项），index，arr（原数组）；

  不同点：
    map的速度比forEach快；
    map会返回一个新的数组，不对原数组产生影响，forEach不会产生新的数组；
    map因为返回的是数组所以可以链式操作，forEach不能；
####  object.assign函数的作用及用法，举例说明？
  Object.assign用于对象合并，将源对象的所有可枚举的属性，复制到目标对象，第一个参数是目标对象，后面的参数是源对象呢。如果目标对象与源对象或多个源对象有同名属性，则后面的属性会覆盖前面的属性；
  
  如果只有一个参数，Object.assign会直接返回该参数。如果该参数不是对象，会先转成对象，然后在返回，有与undefined和mull无法转成对象，所以如果他们作为参数就会报错；

  只拷贝源对象的自身属性，不拷贝继承属性，也不拷贝不可枚举属性；

  浅拷贝，而不是深拷贝，如果源对象某个属性的值是对象，那么目标对象拷贝得到的就是这个对象的引用

#### proxy？
  proxy对象用于定义基本操作的自定义行为
  let p = new Proxy(target,handler);
    targets是你要代理的对象，他可以是js的任何一种合法对象；
    handler是你要自定义操作方法的一个集合；
    p是一个被代理后的新的对象，他拥有target的一切属性和方法，只不过其行为和结果在handler里面自定义；

#### 使用proxy代理？
  let book = {"name":"《ES6基础系列》"，"price":56};
  let proxy = new Proxy(book,{

    get:function(target,property){
      if(property === 'name'){
        return "<入门>"
      }else{
        return target[property]
      }
    },
    set:function(traget,property,value){
      if(property === 'price'){
        target[property] = 56;
      }
    }
  })

#### promise？
  promise是一个异步函数，主要是为了解决异步处理回调地狱（也就是循环嵌套的问题）而产生的；

#### ES6的继承和ES5的继承有什么区别？
  ES5的继承主要是通过原型或者是构造函数机制来实现的，ES6通过class关键字来定义类，里面有构造函数的方法，类之间通过extends关键字来实现继承，子类必须在constructor中调用super方法；

#### http和https的概念？
  http是应用最为广泛的一种协议，是客户端和服务端请求和响应的标准；
  https是以安全为目标的http通道，就是http的安全版，即http下加入ssl层，https的安全基础就是ssl
  https的协议作用分为两种：建立一个安全的信息通道；确认网站的真实性；
  区别：
    http协议都是未加密的，https协议是通过ssl和http协议构建进行加密传送的，所以https更加安全；

#### transform:translate(0)作用：cpu加速，优化前端性能；
#### 精确的获取页面元素的位置方式：getBoundingClientRect（）；




### js部分

#### 原型中的prototype和——proto_的区别？
  js中所有的对象都是object的实例，并继承了object.prototype的所有属性和方法；在对象创建时就有一个预定的属性prototype，而prototype也是一个普通的对象；而定义一个普通对象的时候，就会生成一个——proto——，这个指向这个对象的构造函数的prototype；

#### 什么是闭包？
  闭包是能够读取其他函数内部变量的函数；
  优点：
	1、避免全局变量的污染；
	2、希望一个变量长期缓存在内存中；
  缺点：
	1、内存泄漏
	2、常驻内存增加内存使用量；
#### 如何能解决内存泄漏的问题？
	出现内存泄漏的情况
		1、全局变量（未声明的变量，用this创建的变量）
		2、闭包
		3、事件监听，对同一个事件重复监听，但是忘记移除，会导致内存泄漏；
		4、定时器，用过之后没有清除；
	前端如何检查内存是否泄漏/
	node-->process.memoryUsage();heapUsed来判断；
	如何解决？
		如果是变量导致的内存泄漏，将变量清除a=null即可；
		事件监听导致的内存泄漏，监听后移除即可
#### 闭包的原理？
  上级作用域无法访问下级作用域中的变量，但下级作用域可以访问上级作用域中的变量

#### 闭包的作用？
  让外界读取某个函数内部的变量；
  让这些变量始终保存在内存中；
  可以通过闭包返回的函数或者方法，来修改函数内部的数据；
#### 浅拷贝的使用场景？
	1、Object.assign();用于对象合并，将源对象的所有可枚举属性，复制到目标对象；
		1、如果只有一个参数，Object.assgin将直接返回，
			如果该参数不是对象，那么会先转成对象
			由于undefined和null无法转换为对象，所以会报错；
		2、如果非对象的参数不出现在target位置，那么会先转成对象，如果无法转成对象，那么会直接跳过，并不会报错；
		3、其他类型的值（即数值、字符串和布尔值）不再target，也不会报错；但是字符串会转成数组，然后拷贝到目标对象中
#### 如何实现一个深拷贝？
	function isObject(source){
		return typeof source == 'object' && source != null
	}
	function deepClone(source){
		if(!isObject(source)) return source;
		var target = Array.isArray(source) ? [] : {};
		for(let key in source){
			if(Object.prototype.hasOwnProperty.call(source,key)){
				if(isObject(source[key])){
					target[key] = deepClone(source[key])
				}else{
					target[key] = source[key];
				}
			}
		}
		return target
	}	

#### 数组去重放入方法？
	1、es6的set
	2、let arr = [1,3,4,5];
		deWeight(arr)
		function deWeight(arr){
			let newArr = [];
			arr.forEach(item => {
				if(newArr.indexOf(item) == -1){
					newArr.push(item)
				}
			});
			return newArr
		}
	3、reduce()
		let arr = [2,324,24,234,23423,4];
		let arr2 = arr.reduce(function(ar,cur){
			if(!ar.includes(cur)){
				ar.push(cur)
			}
			return ar
		},[]);
		
	4、数组对象如何去重？
	
		let obj = {};
		let arr1 = arr.reduce(function(item,next){
			obj[next.key] ? '' : obj[next.key] == true && item.push(next);
			return item
		},[])

#### dom事件有哪些阶段？谈谈对事件代理的理解？
	捕捉阶段->目标阶段->冒泡阶段
	事件委托：利用事件冒泡的特性。将本该注册在子元素上面的事件注册到父元素上，这样点击子元素时发现本身没有事件就会到父元素上面去找
	优点：减少dom操作，提高性能；随时可以添加子元素；

#### 什么是XSS？
   跨站脚本攻击，
  预防的方法？
    预防用户的输入，不用innerHTML，用innerText；
    核心就是必须对输入的数据做过滤处理，对用的输入进行过滤

#### 什么是web标准？
  web标准不是某个标准，而是一系列标准的集合。网页主要由三部分组成：结构，表现，行为；
  对应的标准也是分三个方面的：结构化标准语言主要包括xhtml和xml，表现标准语言主要包括css，行为标准包括对象模型，es等

#### 什么是w3c？
  web标准规范要求，书写标签必须闭合，标签小写不乱嵌套，可以提高搜索机器人对与网页内容的搜索几率；
  建议使用外链的css和js脚本，从而达到结构，表现和行为的分离，提高页面的渲染速度；
  样式与标签分离，更合理的与语意化标签，使内容能够被更多的用户所访问，被更广泛的设备所访问，更少的代码和组件，从而降低维护成本，改版更方便；


#### 什么是webpack？
  webpack是把项目当作一个整体，通过一个给定新的主文件，webpack将从这个文件开始找到项目所有的依赖文件，使用loader处理他们，最后打包成一个或者是多个浏览器可以识别的js文件；
  
  webpack-dev-server是用来创建本地服务器的，，监听代码修改，并自动刷新修改后的结果

  entry：用来写入口文件，它将是整个依赖关系的根

  loader的作用：
      实现不同格式的文件处理，比如将scss转化为css等；
      转化这些文件，从而使其能够被添加到依赖图中

  常用的loader：
    babel-loader：让下一代的js文件转换为现在浏览器能够支持的js文件；
    css-loader，style-loader：是用来解析css文件的，
    url-loader：生成的文件名就是文件内容md5哈希值，并会保留所引用资源的原始扩展名

  plugins和loader的区别？
    loaders负责的是处理源文件的，一次处理一个文件，而plugins并不是直接操作单个文件，他直接对整个构建过程起作用

  extract-text-webpack-plugin:他将入口中引用css文件，都打包成独立的css文件，而不是内嵌在js打包文件中的
  HtmlwebpackPlugin:
	1、为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题
	2、可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面入口
github上有些关于htmlwebpackplugin的属性介绍



#### 什么是webpack？与grunt和gulp有什么不同？
  gulp/grunt是一种能够优化前端的开发流程的工具，而webpack是一种模块化的解决方案；
  gulp和grunt的工作方式：在一个配置文件中，指明对某些文件进行编译，组合，压缩等任务的具体步骤，之后工具可以自动完成这些任务；
  webpack的工作方式：本项目当作一个整体，然后给一个主dssss文件，就会以这个主文件开始，查找项目所有的依赖文件，使用loaders处理里他们，最后打包成为一个或者多个浏览器可识别的js文件；

  gulp和grunt需要开发者将整个前端构建过程拆分为多个任务，并合理控制所有任务之间的调用关系；
  webpack需要开发者找到入口，并清楚对与不同的资源应该使用什么loaders做何种解析加工；

#### webpack的优点?
  专注于处理模块化的项目，能够做到开箱即用，一步到位；
  可通过plugin扩展，方便、灵活；
  社区庞大活跃，经常引入新的特性
  良好的开发体验

#### 分别介绍bundle，chunk，module是什么？
bundle：是由webpack打包出来的文件；
chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割；
module：是开发中的单个模块，一个模块的对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块；

#### 什么是loader？什么是plugin？两者的区别？
  loader：模块转化器，用于把模块源内容按照需求转换为新内容，通过使用不同的loader，webpack可以把不同的文件转换为js文件；
  plugin：扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或者是你想要做的事情；
  loader是用来对模块的源代码进行转换，而插件的目的就是解决loader无法实现的其他事情，因为plugin可以在任何阶段调用，能够跨loader进一步加工loader的输出；

#### 什么是模块热更新？
  模块热更新是webpack的一个功能，他可以使的代码修改过后不用刷新浏览器就可以更新

#### 几个常见的pulgin和常见的loader？
  plugin：
    html-webpack-plugin为html文件中引入的外部资源添加hash值，也可以生成html入口的文件；
    mini-css-extract-plugin分离css文件；
    clean-webpack-plugin删除打包文件；
    hotModulereplacementplugin热更新应用；
    copy-webpack-plugin拷贝静态文件
    commons-chunk-plugin提取公共代码；


#### webpack-dev-server和http服务器如nginx有什么区别？
  webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并可以使用模块热更新，他比传统的http服务更加简单高效

#### webpack构建过程？
  从entry里面的配置module开始递归解析entry依赖的所有模块；
  每找到一个模块就会根据配置的loaders去找对应的转化规则；
  对module进行转化后，在解析出当前的module所依赖的module；
  这些模块会以entry为单位分组，一个entry和其所有依赖的module别分到一组chunk；
  最后webpack会把所有的chunk转换成文件输出。
  在整个流程中webpack会在强档的时候执行plugin里面定义的逻辑；

详细：
  1、初始化参数：从配置文件和shell语句中读取于合并参数，得到最终的参数；
  2、开始编译：用得到的参数初始化complier对象，加载所有配置的插件，执行兑现的run方法开始编译；
  3. 确定入口：根据配置中的entry找到所有的入口文件；
  4. 编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，在找到该模块依赖的模块，在递归本步骤找到所有入口依赖文件都经过本步骤的处理；
  5. 完成模块编译：在经过地4步使用loader翻译完成所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系；
  6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，在把每个chunk转化为单独的文件加入到输出列表；
  7. 输出完成；在确定好输出内容后，根据配置确定输出的路径和文件名，把内容写到文件系统中；
#### 什么是常缓存？在webpack中如何做到常缓存优化？
  浏览器在用户访问的时候，为了加快加载速度会对用户访问的静态资源进行存储，但是每次代码升级或者是更新都需要浏览器下载新的代码，最简单方便的方式就是引入新的文件名称；
  webpack中可以在output中指定chunkhash，并且分离不经常更新的代码和框架代码，通过namemoduleplugin和hashmodulesplugin使在此打包文件名不变；

#### 如何利用webpack来优化前端性能；
  1.压缩代码。删除多余代码，注释，简化代码的写法等等。可以利用webpack的uglifyJSplugin和paralleluglifyplugin来压缩js文件，利用mini-css-extract-plugin来压缩css文件；
  2.利用cdn加速。在构建过程中，将引用的静态资源路径修改为cdn上面对应的路径，可以利用webpack对于output参数和各loader的publicpath参数来修改资源路径；
  3.删除死代码，将代码中永远不会执行的代码片段删除调，可以通过启动webpack时追加参数-optimize-minimzie实现；
  4.提取公共代码，commons-chunk-pulgin；

#### 如何提高webpack的构建速度？
  1.多入口的情况，可以使用commonschunkplugin来提取公共代码；
  2.通过externals配置来提取常用库；
  3.使用webpack-uglify-pararllel来提高uglifyplugin的压缩速度，采用多核并行压缩；


#### 什么是防抖和节流？有什么区别？如何实现？
  防抖和节流的作用都是防止函数多次调用，
  防抖：就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
  节流：就是指连续触发事件但是在 n 秒中只执行一次函数

#### 防抖节流的应用场景？
  防抖：多数用在用户注册时手机号和邮箱的验证，只有用户输入完成后，前端才需要进行检测格式是否正确，如果不正确，在弹出提示于，包括发送验证码，同样是要求一定时间后才能在次操作；
  节流：多数在监听页面元素滚动事件的时候用到，因为滚动事件是一个高频触发的事件；

#### 如何实现源码？
  防抖：重点是需要一个setimout来辅助实现，延迟执行需要跑的代码，如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清楚掉，重新开始，如果计时完毕，没有方法来访问触发，就执行代码；
    <!-- 定义一个常量，接受一个函数和延迟事件作为参数 -->
  const debounce = (fn,delay) => {
    <!-- 定义一个空变量 -->
    let timer = null;
    <!-- 为了保证this指向，返回一个箭头函数 -->
    return (...arg) => {
      <!-- 每次进来都需要清理定时器 -->
      cleartimeout(timer);
      timer = settimeout(() => {
        <!-- 调用applay发榜绑定this-->
        fn.apply(this,args)
      },delay)
    }
  }

  节流：重点声明一个变量当标志位，记录当前代码是否执行，如果没有执行，就正常触发方法执行，如果代码正在执行，就取消这次执行直接return；
  <!-- 定义一个函数，接受函数作为参数，同时设定要求事件 -->
  const throttle = (fn,delay=500) =>{
    <!-- 设置变量默认为true-->
    let flag = true ;
    return (...arg) => {
      if(!flag) return
      flag = false;
      <!-- 设置定时器 -->
      settimeout(() => {
        fn.apply(this,args) ;
        flag =true;
      },delay)
    }
  }
#### session鉴权是怎么做的？有什么问题？
  传统的session认证？
    http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供用户名和密码来进行认证，那么下一次请求时，用户还要在一次进行用户认证才行，因为根据http协议，我们斌股指懂啊是按个用户发出的请求，所以为了让我们的应用能够识别是那个用户发出的请求，我们只能在服务器上存储一份用户的token的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别出来是哪个用户了，这个就是基于seesion认证。
    但这种基于session的认证是应用本身很难得到扩展，随着不同客户端用户的增加，服务器其已经无法承载更多的用户，而这个时候session认证应用的问题就报露出来了；

  基于session认证所暴露的问题？
    1.session：每个用户经过我们应用认证之后，我们的应用都需要在服务端记录一次，以方便用户下次请求的鉴别，通过session都是保存在内存中的，而随着用户的增多，服务端的开销就会明显的增大；
    2.扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这就意味着用户下次请求还必须在这台服务器上，才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，这也就意味着限制了你应用的扩展能力；
    3.csrf：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击


#### 浏览器的兼容问题？
  1.ios上面input标签不能够直接定义height，光标不居中；
  2.new Date()时间转化的时候不兼容-，所有浏览器都兼容/；
  3.ios上面输入框被键盘遮挡：有一个轻微的滚动就可以；

#### css放在头部和js放在尾部优化页面原因：
  css一般用href加载，放在头部；js一边用src加载放在尾部；
  href：可以并行下载资源，不会阻塞当前文档的加载；
  src：浏览器识别到src之后会停止对文档的渲染，直到资源加载完成；

#### jsonp的工作原理以及如何实现的，代码？
  同源策略：域名，协议，端口相同；
  Jsonp是一个非官方的协议，它允许在服务端集成script tags返回至客户端，通过js callback的形式实现跨域访问
  原理：
    首先是利用script标签的src属性来实现跨域的；
    通过将前端方法作为参数传递到服务器端，然后服务器端注入参数后在返回，实现服务器端向客户端通信；
    由于script标签的src属性，因此只能支持get方法；

  优点：他不像xmlhttpRequest对象实现的ajax请求那样受到同源策略的限制，他的兼容性更好，并且在请求完毕之后可以通过调用callback的方式回传结果；
  缺点：他只支持get请求而不支持post请求，只支持跨域的http请求这种情况，不能解决不同域的两个页面之间是如何进行js的调用问题；

后端：
  response.setHeader('access-control-allow-origin'，‘*’)

#### ajax的原理？
  相当于在用户和服务器之间加了一个中间层，使用户操作和服务器响应异步化，并不是所有用户的请求都会提交给服务器，向一些数据验证和数据处理都是交给ajax引擎自己操作的，只有确定需要从服务器中读取新数据时在由ajax引擎代为向服务器提交请求；

#### 一次完整的http请求所经历的7个步骤？
  建立TCP链接；
  web浏览器向web服务器发送请求；
  web浏览器发送请求头；
  web服务器应答；
  web服务器发送应答头；
  web服务器向浏览器发送数据；
  web服务器关闭tcp链接；


  301永久重定向；
  302临时重定向；
  403请求的资源被禁止使用；
  404服务器无法找到资源；
  500服务器内部错误；
  503服务器正忙；
  200请求被正常处理；


#### js有几种数据类型？
  基本数据类型；
  引用数据类型；

  push尾部添加  pop尾部删除；
  unshift头部添加 shift头部删除

#### IE和标准下有哪些兼容的写法
  var ev = ev || window.event;
  document.documentElement.clientwidth  || document.body.clientwidth;
  var traget = ev.srcElement || ev.traget;

#### 如何阻止事件冒泡？
  ie:event.cancelBubble = true;
  非ie：event.stopPropagation();


  阻止默认事件？
  return false；
  event.preventDefault();

#### 函数声明与函数表达式的区别？
  在js中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁的；
  解析器会率先读取函数声明，并使其在执行任何代码之前可用，至于函数表达式，必须等待解析器执行到他所在的代码行，才会被真正的解析执行；

#### null和和undefined的区别？
  null表示空指针的对象，转为数值时为0；
  undefined就是空的原始值，转为数值时为NAN；

#### new操作符具体干了什么？
  创建一个空对象 var obj= new Object（）；
  让空对象的原型属性指向原型链，设置原型链 obj._proto_ = Func.prototype;
  让构造函数的this指向obj，并执行函数体 var result = func.call(obj);
  判断返回类型，如果是指值就返回obj，如果是引用类型，就返回这个对象；

#### 什么是FOUC？你如何来避免FOUC?
  由于css引入使用了@import或者存在多个style标签以及css文件在页面引入使得css加载在html之后导致页面闪烁，花屏；
  使用link加载css文件，放在head标签里面；

#### 文档类型的作用是什么？有哪几种文档类型？
影响浏览器对html代码的编译渲染；

#### js中function换个var的预解析主要有函数参数，函数声明，var变量的声明；
js的语句执行步骤为：
  自身函数参数；
  函数声明；
  var变量；
  其他语句执行；


### js的两种回收机制？
  标记清除；
  引用计数；
  优点：大幅简化程序的内存管理代码，减轻开发者的负担，并没有因为长时间运转而带来的内存问题；
  缺点：自动回收意味这无法掌控内存；

<!--  北大英华 面试题-->
#### 执行顺序
  - is ：解决了html模版的限制；
  - v-for：当v-if与v-for一起使用时，v-for具有比v-if更高的优先级，这就意味着v-if将分别重复运行于每个v-for循环中；不应该一起使用，必要的情况下应该替换称为computed属性，原因：v-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候
  - key：使用v-for更新已经渲染的元素列表时，默认用就地复用策略；列表数据修改的时候，他会根据key值去判断某个值是否需要修改，如果修改，则重新渲染这一项，否则复用之前的元素；
  - v-if
  - v-else-if
  - v-else
  - v-show



#### 执行顺序
- components
- props
- data
- computed
- created
- mounted
- methods
- filter
- watch


#### 返回结果
function sss(x,n){
         if(n<2){
                   return x
         }else{
                   return x*sss(x,(n-1))
         }
}
console.log(sss(2,10)) 2的10次方；

#### 如何理解jquery的链式调用？
  jquery的方法都是挂靠在原型上的，每次在内部方法返回this，也就是返回实例对象，那么我们就可以继续调用原型上面的方法，这样节省了代码量，提高了代码效率，让代码看起来更加的优雅

#### ajax封装的时候如何用jquery进行拦截？
里面有一个beforesend和complete进行拦截


#### 使用ajax和websocket的区别；



<!-- 睿呈时代 -->
#### 如何引用一个自定义的字体？
  @font-face{
    font-family:'字体名称'；
    src：url（’路径‘）
  }
#### 如何写一个三角形？
  #triangle-up{
    width:0;
    height:0;
    border-left:50px solid red;
    border-right:50px solid red;
    border-bottom:100px solid blue
  }
#### 本地图片能显示，打包之后图片不能显示的原因有哪些？
  （1）修改路径位置，解决空白页的问题
      位于项目目录中config/index.js，将assetsPublicPath：'./',变为了相对路径
   (2) 解决背景图片不显示的问题：
      修改build文件夹下的utils.js，中的publicPath：'../../'
##### delete和vue.delete的区别？

#### less和sass的书写规则？
  sass：
    变量：$color:red;
    Import导入模块：@import 'reset',合并导入的文件；
    mixins：sass中的函数方法mixins
      定义一个方法
        @mixin border-radius($radius){
          -webkie-border-raduis:$radius;
          -moz-borer-radius:$radius;
          -ms-border-radius:$radius;
          border-radius:$radius;
        }
      使用方法：.box{ @include border-radius(10px);}
      @extend .message继承


      sass中于px于rem的转化
      @function pxrem($px){
        $rem:75;
        @return ($px/$rem)+rem;
      }
	  
#### 一行文字省略号显示？
  一行文字省略：
    width：500px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;

  多行省略：  
    overflow:hidden;
    text-overflow:ellipsis;
    display:-webkit-box;
    -webkit-box-orient:vertical;
    -webkit-line-clamp:几行；
	
#### 如何让一个元素水平垂直居中？
  方法一：
    position:absolute;
    left:50%;
    top:50%;
    margin-left;
    margin-top;
    兼容性好，缺点必须知道元素的宽高；
  方法二：
    position：absolute；
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    缺点：兼容性不好，只支持ie9+;
  方法三：
    margin：auto；
    兼容性好，不支持ie7一下浏览器；
  方法四：
  display:flex;
  justify-content:center;
  align-items:center;
  
#### px和rem的区别？
  px表示“绝对尺寸”；
    优点:设置px单位的元素尺寸和位置更稳定和精确；
    缺点：无法随着浏览器的缩放动态变化；
  em表示“相对尺寸”
    优点：尺寸大小可以随着设备屏幕的大小变化；
    缺点：需要注意定义当前对象的字体尺寸，如果为定义，该尺寸则相对于浏览器默认字体尺寸
  rem是css3中的一个新增的相对单位，rem参考为根元素的字体大小，所以只需要确定根元素的字体大小 
  
  
#### 判断js类型的方式？
	1、typeof
		可以判断出：string，number，boolean，undefined，smybol；
		null，数组，对象都是object；
	2、instanceof ：原理是构造函数的prototype属性是否出现在对象的原型链中的任何位置；
	3、Object.prototype.toString.call()
	4、判断是否为数组：Array.isArray();
  

#### react

#### react-router和react-router-dom有什么区别？
	react-router:提供了router的核心api。如Router,Route,Switch等，但没有提供有关dom操作进行路由跳转的api；
	react-router-dom:提供了BrowserRouter、Route,Link等api，可以通过dom操作触发事件控制路由。
	
	因此react-router-dom里面包含了react-router的以来，因此我们在安装的时候直接安装cnpm install react-router-dom --save;
	
#### reactRouter中的hashrouter和browserrouter的区别？
	（1）从原理上
		hashrouter在路径上包含了#，相当于html的锚点定位
		browserrouter使用的是html的新特性history，没有hashrouter那样通用，低版本的浏览器可能不支持
	（2）从用法上
		browserrouter进行组件跳转时可以传递任意参数实现组件之间的通信；
		hashrouter不能，因此一般配合redux使用，实现组件间的数据通信；
	（3）从生产实践上
		1.hashrouter：相当于锚点定位，因此不论#后面的路径怎么变化，请求的都相当于是#之前的那个页面。可以很容易的进行前后端不分离的部署（也就是把前端打包后的文件放到服务端的public或者是static里面）；
			因为请求的链接地址都是ip地址：端口/#/xxx,因此请求的资源路径永远为/，相当于index.html,而其他的后端api接口都可以正常请求，不会和/冲突，由于前后端不分离也不会产生跨域的问题。
			
		2.browserrouter：因为browserrouter模式下的请求链接地址都是ip地址：端口/xxx/xxx，因此相当于每个url都会访问一个不同的后端地址，如果后端没有覆盖到的路由就会产生404的错误；
			可以通过加入中间件解决，放在服务端路由匹配的最后，如果前面的api接口都不匹配，则返回index.html页面。但这样也会有一些小问题，因为要求前端路由和后端路由的url是不能重复的；
			
			比如商品列表组件/product/list，而请求商品列表的api也是/product/list，那么就不会访问到该页面，而会被api接口匹配到。
			
			解决办法：
				进行前后端分离部署，比如说前端地址ip1:端口1，后端接口地址ip2:端口2，使用nginx反向代理服务器进行请求分发。前端向后端发起请求的url为nginx所在的服务器+/api/xxx，通过nginx的配置文件判断，如果url以api开头则转发至后端接口，否则转发至前端的地址，访问项目只需要访问nginx服务器即可。
				
#### react-router-dom中的各个组件及用法？
	1.BrowserRouter:使用html5历史记录的api（pushState,replaceState和popState事件）的<Router>来保持uI与URL的同步；
	2.HashRouter：使用url的哈希部分的<路由器>可以保持您的ui和url的同步
	3.Link：为应用提供声明式的，无障碍导航。
	4.NavLink：是link的一个特定的版本，会在匹配上当前url的时候会给已经渲染的元素添加样式参数；
	5.Redirect：渲染时将导航到一个新的地址，这个新地址会覆盖在访问历史信息里面的本该访问的那个地址；
	6.Route：
	7.StaticRouter：当用户实际上没有点击时，这在服务器端渲染场景很有用，因此该位置从未实际更改。因此，名称static，当宁只需要插入一个位置并对渲染输出进行断言时，他也可以用于简单的测试，
	8.Switch：只渲染第一个匹配到的<路由组件>或<重定向组件>,这不同于仅使用一堆<路线>，<Switch>是唯一的，因为他独家呈现路线。相反，与位置匹配的每个<路由>都会包含，
		如果url是"http://127.0.0.1:8080/about"，那么组件<About>,<User>和<NoMatch>将全部渲染，因为他们斗鱼路径匹配。这是通过设计。允许我们以许多方式在我们的饮用程序中编写<Route>,例如侧边栏和面包屑，引导卡等，但是我只想选一个<Route>来渲染
		
#### react中的创建store的createStore? 创建一个store来以存放应用中所有的state；
	createStore(reducer,preloadedstate,enhancer)
	reducer:
	preloadedstate:他是state的初始值，实际上他并不仅仅是扮演一个initialState的角色，如果我们第二个参数是函数类型，createStore会认为你忽略了preloadedstate而传入了一个enhancer，如果我们传入了一个enhancer，createStore会返回enhancer(createStore)(reducer,preloadedState)的调用结果，这是常见高阶调用的方式。在这个低哦啊用中enhancer接受createStore作为参数，对createStore的能力进行增强，并返回增强的createStore。然后在将reducer和preloadedState作为参数传给增强后的createStore，最终生成store
	1.action:代表的是用户的操作，redux规定action一定要包含一个type属性，并且type属性也要是唯一的，相同的type，redux视为同一种操作，因为处理action的函数reducer只判断action中的type属性；
	2.reducer：负责响应action并修改数据的角色，本质上实际是一个函数，其函数签名为：reducer(previousState,action) => newState。可以看出，reducer接受两个参数，previousState以及action函数返回的action对象，并返回一个罪行的state，实际上reducer在处理previousState还需要一个特殊的非空判断；reducer只是一个模式匹配的东西，真正处理数据的函数，一般是额外在别的地方写的，在reducer中调用罢了。
	3.getState:
	4.subscribe:接受一个listener，他的作用是给store添加监听函数。nextListeners存储了整个监听函数列表。subscribe的返回值是一个unsubscribe，是一个解绑函数，调用该解绑函数，会讲已经添加的监听函数删除，该监听函数处于一个必报之中，会一直存在，所以在解绑函数中能删除该监听函数
	5.dispatch：校验action是否为一个原生js对象；action对象是否包含了必要的type字段；判断当前是否处于action分发过程中，这个检查主要是为了避免在reducer中分发action。
	6.replaceReducer
	
	
#### 题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现
	三个亮灯函数已存在
		function red(){
			console.log('red');
		}
		function green(){
			console.log('green');
		}
		function yellow(){
			console.log('yellow');
		}
	一个函数实现时间控制：
		let tic = function(timmer,cb){
			return new Promise((resolve,reject) => {
					setTimeout(() => {
						cb();
						resolve();
					},timmer)
			})
		}
		
	如果把问题简化一下，如果只需要一个周期，那么利用promise应该这样写；
		
		var step = function(def){
			Promsise.resolve().then(() => {
				 return tic(3000,red)
			}).then(() => {
				return tic(2000,green)
			}).then(() => {
				return tic(1000,yellow)
			}).then(() => {
				step()
			})
		};
	step();
	
	
#### 了解promise吗？
	promise是异步回调地狱的解决方案，有三种状态，pending，fulfiled，rejected，存在两个过程，一个是pending->fulfiled（成功），pending->rejected（失败）
#### promise解决的痛点是什么？
	1、回调地狱，代码难以维护
	2、可以支持多个并发请求，获取并发请求中的数据；
	3、解决可读性的问题
	4、解决信任问题，then和catch只能只能被调用一次，因此可以解决信任问题
#### promise解决的痛点还有其他的方法可以解决吗？
	1、setTimeout，事件监听，回调函数、async/awite
	settimeout：不精确，只是在确保一定时间后加入任务对立，并不能保证函数能够立即执行，当主任完成时才能够执行；
	事件监听：任务的狮子难过不取决于代码的顺序，而是取决于事件是否发生；
#### promise如何使用？
	创建一个promise的实例
	实例生成后，可以用then方法分别指定resloved和reject的回调函数
#### promise在事件循环中执行过程是怎么样的？
	事件循环：
		按照代码顺序执行->遇到同步任务立即执行，遇到异步任务，则发起请求->异步任务执行后到消息队列中排队->按照代码执行完毕后，查询队列中是否有等待的消息->you ,则按顺序执行-
	promise的事件循环
		promise在初始化时，传入的函数是同步执行的，然后注册then的回调；
		注册完成之后执行同步代码，then的回调不会执行；
		同步代码执行完毕后，才会在事件循环中检测是否有可用的promise回调，有，则执行
#### promise的问题？解决办法？
	问题：
		1、一旦执行，无法取消；
		2、错误无法在外部捕捉到，只能在内部进行判断；
	解决办法：
		async/awite
#### promise不兼容？
	es6-promise-polyfill
#### finally()
#### 实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。
	const timeout = ms => new Promise((resolve, reject) => {
	    setTimeout(() => {
	        resolve();
	    }, ms);
	});
	
	const ajax1 = () => timeout(2000).then(() => {
	    console.log('1');
	    return 1;
	});
	
	const ajax2 = () => timeout(1000).then(() => {
	    console.log('2');
	    return 2;
	});
	const ajax3 = () => timeout(2000).then(() => {
	    console.log('3');
	    return 3;
	});
	
	const mergePromise = ajaxArray => {
	    // 在这里实现你的代码
		let data = [];
		var sequence = Promise.resolve();
		ajaxArray.forEach(item => {
			sequence = sequence.then(item).then(res => {
				data.push(res);
				return data
			})
		});
		return sequence
	};
	
	mergePromise([ajax1, ajax2, ajax3]).then(data => {
	    console.log('done');
	    console.log(data); // data 为 [1, 2, 3]
	});
	
	// 要求分别输出
	// 1
	// 2
	// 3
	// done
	// [1, 2, 3]
#### 封装一个异步加载图片的方法
	function loadImage(url){
		return new Promise((resolve,reject) => {
			var image = new Image();
			image.onload = function(){
				resolve(image)
			};
			image.onerror = function(){
					reject(new Error('baocio ')）)
			};
			image.src = url;
		})
	}
	
	
#### async/awite
	async/awite用了同步的方式去做异步，async定义的函数的返回值都是promise，awite后面的函数会先执行一边，然后跳出整个async函数来之后后面的js栈的代码
#### transform、translate、transition 分别是什么属性？CSS 中常用的实现动画方式
	1、transform指的是变换，变形，是css3的一个属性；
	2、translate是transform的一个属性值，是指元素进行2d或者是3d纬度上面的一个转换
	3、transition是指过渡效果
#### js的垃圾回收机制？
	定义：是指一块被分配的内存既不能使用、又不能回收，直到浏览器的进程结束；
	js在创建对象的时候会给他们分配内存，不再使用时会释放内存，这个过程成为垃圾回收；
#### 前端性能优化的七大手段
	1、减少请求数量
	2、减少资源大小
	3、优化资源的加载
	4、减少重绘和回流
#### 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
## 外包面试题
	1.如何不用循环，创建一个1-100的数组？
		let arr = Array.from({length:100},(x,y) => y + 1)
		
		let arr1 = new Array(100).keys();
		let arr2 = Array.from(arr1)

#### js实现继承有哪几种方法？
	方法一：原型链继承
		function cat(){}
		cat.prototype = new Animal();
	方法二：构造函数继承
		function Cat(name){
			Animal.call(this);
			this.name = name || 'tom'
		}
		var cat = new cat();
	方法三：组合继承
		function Cat(name){
			Animal.call(this);
			this.name = name || 'tom'
		}
		Cat.prototype = new Anima()；
		var cat = new cat();
#### this指向问题？
	1、全局环境下this指向的是window；
	2、对象函数，this指向的是这个对象；
	3、
#### js判断对象是否是控对象的几种方法？
	1、JSON.stringify(object) === '{}';
	2、Object.keys(Object).length == 0;
	3、$.isEmptyObject(object) == true;
#### js判断对象是否为数组的几种方法？
	1、Array.prototype.isPrototypeOf(arr);
	2、arr instanceof Array；
	3、Array.isArray();
#### 跨域解决方案？
	1、通过jsonp跨域
	3、后端设置header('access-control-allow-origin:*')
	
	方式一：jsonp利用了script标签的src属性，进行跨域的；
	方式二：CORS是一个W3C的标准，全称是“跨域资源共享”，有两种请求：简单请求和非简单请求；
		简单请求：只要同时满足一下两大条件，就属于简单请求
			1、请求方式是一下三种方法之一：HEAD、GET、POST
			2、Http请求头的信息不超过以下几种字段：
				content-type：application/x-www-form-urlencoded 原生的form表单
							：multipart/form-data 表单上传文件
							：application/json
							：text/xml
#### new一个对象，这个过程中发生了什么？
	1.创建一个新的对象，如var obj = {};
	2.新对象的_proto_的属性指向构造函数的原型对象
	3.将this指向新对象
	4.执行构造函数内部的代码，将属性添加给obj中的this对象
	5.返回新对象obj
	
	
	
1、type和interface的区别?
	type:
		1、可以声明基本类型、联合类型、元组的别名
		2、可以使用typeof获取类型实例；
		3、支持映射
	interface：
		1、能够声明合并
		
	相同点：
		1.都可以声明一个对象或是函数
		2.都允许扩展
		
		
		
####react学习
	1.umi-request网络请求
		1.1 定义：umi-request是基于fetch封装的开源http请求，旨在为开发者提供一个统一的api调用方式，同时简化使用方式，提供请求层常用的功能：
				1.url参数自动序列化；
				2.post数据提供方式简化；
				3.response返回处理简化；
				4.请求超时处理
				5.请求缓存支持
				6.gbk编码处理
				7.统一的错误处理方式
				8.请求取消支持
				9.node环境http请求
				10.拦截器机制
				11.洋葱中间件机制
			umi-request底层抛弃了设计粗糙，不符合关注分离的XMLHttpRequest,选择更加语义化，基于标准promise实现的fetch；同时同构更加方便，使用isomorphic-fetch；而基于各业务应用场景提取常见的请求能力并支持快速配置如post简化，前后缀，错误检查等；
			
		2.1 中间件
			每一层洋葱圈为一个中间件，请求经过一个中间件都会执行两次，开发者可以根据业务需求很方便的实现请求前后增强处理：
			实现原理：主要由中间件数组和中间件组合两部分组成，前者负责存储挂载的中间件，后者负责将中间件按照洋葱的结构进行组合并返回真实可执行的函数：
			
			存储中间件：
			class Onion{
				constructor(){
					this.middlewares = []
				}
				<!-- 存贮中间件 -->
				use(newMiddleware){
					this.middlewares.push(newMiddleware)
				}
				<!-- 执行中间件 -->
				execute(params = null){
					const fn = compose(this.middlewares);
					return fn(params)
				}
			}
			
			组合中间件：
				上述代码中的compose即为组合中间件的函数实现，精简逻辑后如下：
				export default function compose(middlewares){
					return function wrapMiddlewares(params){
						let index =  -1;
						function dispatch(i){
							index = i;
							const fn = middlewares[i];
							if(!fn) return Promise.resolve();
							return Promise.resolve(fn(params,() => dispatch(i+ 1)));
						}
						return dispatch(0)
					}
				}
				compose函数通过dispatch(0)先执行了第一个中间件fnfn(params,() => dispatch(i+ 1)),并提供（）=> dispatch(i+1)作为入参供每个中间件能在下一个中间件执行完毕后回来继续执行自己的食物，知道所有中间件完成后执行promise.resolve(),形成洋葱券中间件机制。
				
		3.1	丰富的请求能力
			1.支持node环境发送http请求：基于isomorphic-fetch实现对node环境的请求支持：	
				const umi = require(umi-request);
				const extendRequest = umi.extend({timeout:10000});
				extendRequest("/api/user")
				  .then(res => {
					console.log(res);
				  })
				  .catch(err => {
					console.log(err);
				  });
			
			2.支持自定义内核请求能力：移动端应用一般都会有自己的请求协议如RPC请求，前端会通过SDK去调用客户端请求api,umi-request支持开发者自己封装请求能力
			
	2. react做了什么？
	
		2.1	virtual Dom模型
			virtual dom实际上是对实际dom的一个抽象，是一个js对象，react所有的表层操作实际上是在操作virtual dom。
			经过diff算法会计算出virtual dom的差异，然后将这个差异进行实际的dom操作更新页面。
			  
		2.2 生命周期
		
		2.3 setState机制
			
			2.3.1 理想情况
				setState是“异步”的，调用setState只会提交一次state修改到队列中，不会直接修改this.state.
				等到满足一定条件时，react会合并队列中的所有修改，出发一次update流程，更新this.state.
				因此setSate机制减少了update过程的触发次数，从而提高了性能。
				由于setState会触发update过程，因此在update过程中必经的生命周期中调用setSate会存在循环调用的情况。
				另外用于监听state更新完成，可以使用setState方法的第二个参数，回调函数。在这个回调中读取this.state就是已经批量更新后的结果。
				
			2.3.2 特殊情况
				在实际开发中，setState的表现有时会不同于理想情况，主要是以下两种：
				在mount流程中调用setState，不会进进入update流程，队列在mount时合并修改并render。
				在setTimeout/promise回调中调用setState，将不会进行队列的批更新，而是直接触发一次update流程。
				这是由于setState的两种机制导致的，只有在批量更新模式中，才会是“异步”的。
				
		2.4 diff算法
			diff算法用于计算出两个虚拟dom的差异，是react中开销最大的地方。
			
			传统的diff算法通过循环递归对比差异，算法复杂度为O（n3）。
			
			react diff算法定制了三条策略，将算法复杂程度从O（n3）降到了O（n）
				2.4.1 webui中dom节点跨节点的操作特别少，可以忽略不计
				2.4.2 拥有相同类的组件会拥有相似的dom结构。拥有不同类的组件会生成不同的dom结构。
				2.4.3 同一层级的子节点，可以根据唯一的id来区分
				
			针对这三个策略，react diff实施的具体策略是：
				1.diff对树进行分层比较，只对比两棵树同级别的节点。跨层级移动节点，将会导致节点删除，重新插入，无法复用。
				2.diff对组件进行类比较，类相同的递归diff子节点，不同的直接销毁重建。diff对同一层级的子节点进行处理时，会更具key惊醒简要的复用。两棵树中存在相同的key的节点时，只会移动节点。
				
			另外	，在对比同一层级的子节点时：
				diff算法会议新书的第一个子节点作为起点遍历新树，寻找旧树中与之相同的节点。
				如果节点存在，则移动位置。如果不存咋，则新建一个节点。
				在这个过程中，维护了一个字段lastindex，这个字段表示已遍历的所有新树子节点在旧树中最大的index。在移动操作时，只有旧的index小于lastindex的才会移动。
				这个顺序优化方案实际上是基于一个假设，大部分的列表操作应该是保证列表基本有序的。
		3.性能优化方案
			由于react中性能主要耗费在于update阶段的diff算法，因此性能优化也主要针对diff算法。
					
			3.1 减少diff算法触发次数
				减少diff算法触发次数实际上就是减少update流程的次数。
				正常进入update流程有三种方式：
				
				3.1.1 setState
						setState机制在正常运行时，由于批更新策略，已经降低了update过程的次数。因此，setState优化主要在与非批更新阶段中（timeout，proimse），减少setState的触发次数。常见的业务场景及处理接口回调时，无论数据处理多么复杂，保证最后只调用一次setState。
						
				3.1.2  父组件render
						父组件的render必然会触发子组件进入update阶段（无论props是否更新）。此时最常用的优化方法即为shouldComponentUpdate方法。
						最常见的方式为进行this.props和this.state的浅比较来判断组件是否需要更新。或者直接使用pureComponent，原理一致。
						
			
	4. 事件系统
		在react底层，主要对合成事件做了两件事：事件委派和自动绑定
		
	    4.1 事件委派
			事件代理机制：并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或者卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用，这样简化了事件处理和回收机制，效率也有很大的提升。
		
		4.2 自动绑定
			在react组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。而且react还会对这种引用进行缓存，以达到cpu和内存的最优化，在使用es6 class或者纯函数时，这种自动绑定就不复存在了，需要手动实现this的绑定
		
		4.3 对比react合成事件和js原生事件
			4.3.1 事件传播与阻止事件传播
					react的合成事件并没有实现事件捕获，仅仅支持了事件冒泡机制，阻止原生事件传播需要使用e.preventDefault()，在react合成事件中，只需要使用 e.prevent-Default() 即可
					
			4.3.2 事件类型
					react合成事件的事件类型是js事件类型的一个子集；
			4.3.3 事件绑定方式
					4.3.3.1 直接在dom元素中绑定
					4.3.3.2 通过为元素的事件属性赋值的方式实现绑定
								el.onclick = e => { console.log(e); }
					4.3.3.3 通过事件监听函数来实现绑定
					react合成事件的绑定方式简单
								<button onClick={this.handleClick}>Test</button>
			4.3.4 事件对象
					原生 DOM 事件对象在 W3C 标准和 IE 标准下存在着差异；而在 React 合成事件系统中，不存在这种兼容性问题
	
	5.什么是react hook？
		react hook作用：可以让我们在函数式组件中添加state，也可以让我们使用部分生命周期钩子函数。
		
		5.1 hook特点
			5.1.1 无需修改组件结构的情况下复用状态逻辑
			5.1.2 可将组件中相互关联的部分拆分成更小的函数，复杂组件将变的更容易理解
			5.1.3 每个组件内的函数（包括事件处理函数，effects，定时器或者api调用等等）会捕获某次渲染中定义的props和state
			5.1.4 memo缓存组件，useMemo缓存值，useCallback缓存函数
			5.1.5 每次render都有自己的props和state，每次render都有自己的effects
			5.1.6 当我们更新状态的时候，react会重新渲染组件，每次渲染都能够拿到独立的状态，这个状态值是函数中的一个变量
			5.1.7 没有先行的生命周期，所有渲染后的执行方法都在useEffect里面统一管理
			5.1.8 函数式编程，不需要定义constructor，render，定义class
			5.1.9 某个组件，方法需不需要渲染，重新执行完全取决于你，而且十分方便管理

		5.2 useEffect
			函数式组件中不存在传统类组件生命周期的概念
			会捕获props和state，所以即便在回调函数里，你拿到的还是最初的props和state；
		5.3 useMemo
			跟vue中的computed计算属性很类似
			主要用来解决使用react hooks产生的无用渲染的性能问题，使用functioned形式来解决
			
	6. 组件的生命周期
		6.1 组件装载过程依次调用的生命周期函数
			constructor -> componentWillMount -> render -> componentDidMount
		6.2 组件更新过程依次调用的生命周期函数
			componentWillReceiveProps -> shouldcomponentUpdate -> componentWillUpdate  -> render -> componentDidUpdate
			
		6.3 组件卸载过程
			componentWillUnmount
			
	7. react-router-dom中的组件
		7.1 BrowserRouter :路由组件包裹层。<Route>和<Link>的包裹层
				会创建一个专门的history对象，用来记录路由，从而能够返回上一页或者跳转到指定的路由页面；
				区别于hashRouter，有相应请求的服务器时使用<BrowserRouter>，使用的是静态文件的服务器，则用<HashRouter>
				属性：
					basename:string   //为里面的子目录提供基础路径名
					getUserConfirmation：function  //用于确认导航的功能
					forceRefresh:bool //如果为true，则路由器将在页面导航中使用整页刷新
					keyLength:number 设置它里面路由的location.key的长度，key
的作用：点击同一个链接时，每次该路由下的location。key都会改变，可以通过key的变化来s刷新页面

	7. 按需加载
		通过import()方法加载组件，在通过高阶组件处理import返回的promise结果
		
		<!-- asyncComponent.js -->
		import React,{Component} from 'react';
		
		export default loadComponent => {
			class ASyncComponent extends Component{
				state = {
					Component:null,
				}
				async componentDidMount(){
					if(this.state.Component !== null) return
					
					try{
						const {default :Component} = await loadComponent();
						this.setState({Component})
					}catch(err){
						console.error('Cannot load component in <AsyncComponent />')
						throw err
					}
				}
				
				render(){
					const {Component} = this.state;
					return (Component) ? <Component {...this.props} /> :null
				}
			}
		}
	
		如下使用
			import asyncComponent from './asyncComponent'
			const Demo = asyncComponent(() => import('views/demo.js'))
			<Route path="/demo" component={Demo}>
		
	8.登陆配置及判断
		import {Route,Redirect} from 'react-router-dom'
		export default class extends Component {
			render(){
				let {component:Component,...rest} = this.props
				<!-- 是否需要登陆 -->
				if(!store.getState().user.user.name){
					return <Redirect>
				}
				return <route {...rest} component={Component} />
			}
		}
		
		<!-- 生成route -->
			const renderRouteComponent = routes => routes.map((route,index) => {
				if(route.auth){
					return <AuthRoute key={index} {...route}>
				}
				return <Route key={index} {...route}>
			})
				
	9. react hook实现和由来以及解决问题
		
		
		
			
####微信小程序
	1.文件类型与部分文件说明
		.wxml:微信模版文件，类似于html文件
		.wxss:微信样式文件，类似于css文件
		.js:脚本文件，逻辑代码文件
		.json:静态数据配置文件
		
		app.json--小程序全局配置文件
			pages---页面数组定义
			window---定义所有页面的样式
			tabBar--用来定义tabBar的样式
			
		project.config.json---开发者工具配置
			用来定义版本信息，以及个性化定制
		
		
	2.微信小程序与页面开发的区别
		我们都知道浏览器渲染层和逻辑层都是同一线程处理，所以会存在阻塞的情况；
		但是微信小程序由不同县城处理，逻辑层在jscore中
		
		运行环境     逻辑层             渲染层
		ios         javaScriptCore    WKWebView
		android     V8                chromium定制内核
		开发者工具    NWJS              chrome webview
		
	3.json文件的写法
		3.1  json文件都是被包裹在{}中，并以key-value方式展示，注意key一定要加上双引号，没加双引号，或者是单引号都会报错
		3.2  json的值只能是数字，字符串，布尔值，数组，对象，或者是null
		3.3  json文件中无法使用注释，

	4.this.setData和直接赋值的区别？
		两者否可以造成data里面数据的改变，但是this.setData赋值才会造成wxml里面数据的改变，也就是同步更新渲染界面，而直接赋值只会让data里数据发生变化，并不会改变
		
	5.背景图片
		css中无法使用本地资源的图片作为background-image。可以使用网络资源，或者是base64
	，或者是image标签；
	
	6.组件之前传值的方式
		6.1 直接传值
				设置一个名为myValue的属性，这个属性直接传给组件，但是组件先宣布一个变量。
				properties:{
					myValue:string
				}
		6.2 数据绑定传值
				只需要改变设置属性的方式
		6.3 双向数据绑定
				这个方法数据改变的话，优惠该拜年组件中属性的值
	
	7.生命周期
		应用生命周期 、页面生命周期 、应用生命周期影响页面生命周期
		
		7.1 应用生命周期
			Launch--------------->show--------------->hide
					小程序初始化          后台运行或唤起
					
			7.1.1 用户首次打开小程序，出发onLanuch(全局只触发一次)；
			7.1.2 小程序初始化完成后，触发onShow方法，监听小程序的显示；
			7.1.3 小程序从前台进入后台，触发onHide方法;
			7.1.4 小程序从后台进入前台显示，触发onShow方法;
			7.1.5 小程序后台运行一定的时间，或者是系统资源占用过高，就会被销毁
			
		7.2 页面生命周期
								Unload
					   页面卸载	||
			Load ------------> Show -----------> Ready
					页面载入     ｜｜   初次渲染
			                   Hide
							   
			7.2.1 小程序注册完成后，加载页面，触发onLoad方法；
			7.2.2 页面载入后触发onShow方法，显示页面；
			7.2.3 首次显示页面，会触发onReady方法，渲染页面元素和样式，一个页面只会调用一次
			7.2.4 当小程序后台运行或跳转到其他页面时，触发onHide方法
			7.2.5 当小程序由后台进入到前台运行或重新进入页面时，触发onShow方法
			7.2.6 当使用重定向方法wx.redirectTo或关闭当前页面返回上一个页面wx
			      .navigateBack(),触发onUnload
			
		7.3 应用生命周期影响页面生命周期
			7.3.1 小程序初始化完成后，页面厚赐加载触发onLoad，只会出发一次
			7.3.2 当小程序进入到后台，先执行页面onHide方法在执行应用onHide犯法
			7.3.3 当小程序从后台进入到前台，限制性应用onShow方法在执行页面onShow方法
			
	8.数据请求怎么封装
		8.1 将所有的接口放在统一的就是文件中并导出
		8.2 在app.js创建封装请求数据的方法
		8.3 在子页面中调用封装的方法请求数据
		
	9. 参数传值的方法
		9.1	给html元素中添加data-*属性来传递需要的值，之后通过e。currentTarget.dataset或onload的param参数来获取。注意不能有答谢字母，不可以存放对象；
		9.2 跳转页面时通过navigator传递需要的参数值
		9.3 设置id的方法标识，通过e.currentTarget.id获取设置的id值，然后通过设置的全局变量的方法来传递数据
		
	10. 提高小程序的应用速度的方法
		10.1 减少默认data的大小
		10.2 组件化方案
		
	11. 小程序的优缺点
		11.1 优点
			11.1.1 无需下载
			11.1.2 打开速度快
			11.1.3 开发成本低
			11.1.4 为用户提供良好的安全保障，发布有一套严格的审核流程，不能同哟审查的程序无法发布上线
			11.1.5服务请求快
			
		11.2 缺点
			11.2.1 依托微信，不能开发后台管理功能
			11.2.2 大小限制不能超过2M，不能打开超过5个层级的页面
			
	12. 简述小程序的原理
		小程序分为两个部分webview和appservice，webview用来展现ui，appservice用来处理业务逻辑，数据以及接口调用，他们在两个进程中运行，通过系统层jsbridge实现通信，完成ui渲染，事件处理
	13. webview中的页面怎么跳回小程序中？
		13.1 现在管理后台配置域名白名单
		13.2 然后引入jweixin.js，最后
				wx.miniProgram.navigateTo({url:''})
				
	14. webview的页面怎么跳转到小程序导航的页面？
		小程序导航的叶脉呢可以通过switchTab，但默认情况是不会重新加载数据的，若需加载新的数据，则在success属性中加入一下代码即可：
		success：function(e){
			var page = getCurrentPages().pop();
			if(page == undefined || page == null) return 
			page.onLoad();
		}
		
		webview的页面，则通过 wx.miniProgram.switchTab({url:''});
	
	15. 几种跳转，小程序内的页面跳转
		wx.navigateTo----保留当前页面，跳转到应用内的某个页面，但是不能跳到tabbar页面
		wx.redirectTo----关闭当前页面跳转到应用内的某个页面，但是不允许跳转到tabbar页面
		wx.switchTab----跳转到tabbar页面，并关闭其他所有非tabar页面，路径不能带参数
		wx.navigateBack--关闭当前页面，返回上一页面或多级页面，通过个体CurrentPage()获取当前的页面栈，决定需要返回几层
		wx.reLaunch--关闭所有的页面，打开到应用内的某个页面
		
		
#### nginx配置
	1.nginx是一个异步框架的web服务器，也可以用作反向代理，负载均衡和http缓存
	
	2.什么是代理？
		代理:就如同生活中的专卖店～客人到专卖店买一双鞋子，这个专卖店就是代理，被代理角色就是厂家，目标角色就是用户。
		
	3.什么是反向代理？
		主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息
		
	4.什么是正向代理？
		客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自那个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息；
	
	5.什么是负载量？
		上面客户端发送的、nginx反向代理服务器接收到的请求数量，就是我们说的负载量；
		
	6.什么是均衡？
		请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则；
		
	7.什么是负载均衡？
		将服务器接收到的请求按照规则分发的过程；
		
	8.基本命令
		nginx -t  检查配置文件是否有语法错误
		nginx -s reload 热加载，重新加载配置文件
		nginx -s stop 快速关闭
		nginx -s quit 等待工作进程处理完成后关闭


		
#### 32个手写js，巩固js基础
	
	1.数据扁平化：是指将一个多维数组变为一个一维数组
		
#### content-visibility——只需一行CSS代码，让长列表网页的渲染性能提升几倍以上！
	content-visibility
	1. visible：默认值,对布局和呈现不会产生什么影响
	2. hidden：元素跳过其他内容的呈现，用户代理功能（例如，在页面中查找，按tab健顺序导航等）不可访问已跳过其内容的呈现，也不能选择或聚焦。类似于对其内容设置了display：none属性。
	3. auto：对于用户可见区域的元素，浏览器会正常渲染其内容，对于不可见区域的元素，浏览器会暂时跳过其内容的呈现，等到其处于用户可见区域时，浏览器在渲染其内容。






list:[{
	stat_time: "2020-12-28 00:00:00",
	3:'1000',
	1:'100',
	2:'1000',2000
	count:2000
}]
			
		
		
		
	
		
	
				
	
		
			
				
			
